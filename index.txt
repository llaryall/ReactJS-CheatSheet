1:"$Sreact.fragment"
2:I[87555,[],""]
3:I[31295,[],""]
5:I[59665,[],"MetadataBoundary"]
7:I[59665,[],"OutletBoundary"]
a:I[74911,[],"AsyncMetadataOutlet"]
c:I[59665,[],"ViewportBoundary"]
e:I[26614,[],""]
:HL["/ReactJS-CheatSheet/_next/static/css/b5e22d5c71353178.css","style"]
0:{"P":null,"b":"Kdgd4rQcZqwMJhmqbpCRO","p":"/ReactJS-CheatSheet","c":["",""],"i":false,"f":[[["",{"children":["__PAGE__",{}]},"$undefined","$undefined",true],["",["$","$1","c",{"children":[[["$","link","0",{"rel":"stylesheet","href":"/ReactJS-CheatSheet/_next/static/css/b5e22d5c71353178.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}]],["$","html",null,{"lang":"en","children":["$","body",null,{"className":"__variable_fc7dca __variable_2931ee antialiased","children":["$","$L2",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L3",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":404}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],[]],"forbidden":"$undefined","unauthorized":"$undefined"}]}]}]]}],{"children":["__PAGE__",["$","$1","c",{"children":["$L4",["$","$L5",null,{"children":"$L6"}],null,["$","$L7",null,{"children":["$L8","$L9",["$","$La",null,{"promise":"$@b"}]]}]]}],{},null,false]},null,false],["$","$1","h",{"children":[null,["$","$1","xDv2au4D9Qf-6nOBcaTPK",{"children":[["$","$Lc",null,{"children":"$Ld"}],null]}],null]}],false]],"m":"$undefined","G":["$e","$undefined"],"s":false,"S":true}
f:"$Sreact.suspense"
10:I[74911,[],"AsyncMetadata"]
6:["$","$f",null,{"fallback":null,"children":["$","$L10",null,{"promise":"$@11"}]}]
9:null
d:[["$","meta","0",{"charSet":"utf-8"}],["$","meta","1",{"name":"viewport","content":"width=device-width, initial-scale=1"}]]
8:null
11:{"metadata":[["$","title","0",{"children":"ReactJS Cheatsheet"}],["$","meta","1",{"name":"description","content":"Generated by create next app"}],["$","link","2",{"rel":"icon","href":"/ReactJS-CheatSheet/favicon.ico","type":"image/x-icon","sizes":"16x16"}]],"error":null,"digest":"$undefined"}
b:{"metadata":"$11:metadata","error":null,"digest":"$undefined"}
12:I[33063,["449","static/chunks/449-5ba85a71eea96fd6.js","974","static/chunks/app/page-eeed0adb8e539a8a.js"],"Image"]
13:I[69356,["449","static/chunks/449-5ba85a71eea96fd6.js","974","static/chunks/app/page-eeed0adb8e539a8a.js"],"default"]
14:T4e2,<h3>JSX: JavaScript XML</h3>
<p>JSX lets you write HTML-like syntax directly in JavaScript.</p>
<p><strong>Basic Syntax</strong></p>
<div>
<div>
<pre class="language-javascript"><code>function Welcome() { return &lt;h1&gt;Hello World!&lt;/h1&gt;; }</code></pre>
</div>
</div>
<p><strong>Curly Braces for JavaScript</strong> Use <code>{}</code> to embed JavaScript expressions:</p>
<div>
<div>
<pre class="language-javascript"><code>function Greeting({ name }) { const time = new Date().getHours();
   return ( 
     &lt;div&gt;
       &lt;h1&gt;Hello {name}!&lt;/h1&gt;
       &lt;p&gt;It's {time &gt; 12 ? 'afternoon' : 'morning'}&lt;/p&gt;
     &lt;/div&gt; );
 }</code></pre>
</div>
</div>
<p><strong>className (not class)</strong></p>
<pre class="language-javascript"><code> &lt;div className="container"&gt;Content&lt;/div&gt; // ‚úÖ Correct
&lt;div class="container"&gt;Content&lt;/div&gt; // ‚ùå Wrong </code></pre>
<p><strong>Other Key Differences</strong></p>
<ul>
<li><code>htmlFor</code> instead of <code>for</code></li>
<li>camelCase for event handlers: <code>onClick</code>, <code>onChange</code></li>
<li>Self-closing tags need <code>/</code>: <code>&lt;img /&gt;</code>, <code>&lt;br /&gt;</code></li>
</ul>15:T40e,<h3>Functional Components</h3>
<p>Modern React components are written as JavaScript functions that return JSX.</p>
<p><strong>Basic Syntax</strong></p>
<pre class="language-javascript"><code>function MyComponent() { 
    return 
       &lt;div&gt;Hello from a component!&lt;/div&gt;
 } 
const MyComponent = () =&gt; {
    return 
       &lt;div&gt;Hello from a component!&lt;/div&gt;
} // Arrow function version</code></pre>
<p><strong>Why Functional Components?</strong></p>
<ul>
<li><strong>Simpler</strong>: Less code, easier to read</li>
<li><strong>Modern</strong>: Work with React Hooks (the current standard)</li>
<li><strong>Performance</strong>: Generally more efficient</li>
<li><strong>Testing</strong>: Easier to test as pure functions</li>
</ul>
<div>
<div>
<div>&nbsp;</div>
</div>
<div>
<pre class="language-javascript"><code>function Button({ text, onClick }) {
  return &lt;button onClick={onClick}&gt;{text}&lt;/button&gt;;
}  // Clean, simple functional component
</code></pre>
</div>
</div>16:T4ca,<h3>Props: Passing Data</h3>
<p>Props allow you to pass data from parent components to child components.</p>
<p><strong>Parent to Child Data Flow</strong></p>
<pre class="language-javascript"><code>// Parent component
function App() {
  return (
    &lt;UserProfile 
      name="John" 
      age={25} 
      isActive={true} 
    /&gt;
  );
}

// Child component
function UserProfile({ name, age, isActive }) {
  return (
    &lt;div&gt;
      &lt;h2&gt;{name}&lt;/h2&gt;
      &lt;p&gt;Age: {age}&lt;/p&gt;
      &lt;span&gt;{isActive ? "üü¢ Online" : "‚ö´ Offline"}&lt;/span&gt;
    &lt;/div&gt;
  );
}</code></pre>
<p><strong>Props are Read-Only</strong></p>
<pre class="language-javascript"><code>function Welcome({ name }) {
    name = "Something else";  // ‚ùå Can't modify props
    return &lt;h1&gt;Hello {name}&lt;/h1&gt;;
}</code></pre>
<p><strong>Any Data Type</strong></p>
<pre class="language-javascript"><code>&lt;BlogPost 
  title="My Post"           // string
  likes={42}                // number
  published={true}          // boolean
  tags={['react', 'js']}    // array
  author={{ name: 'Jane' }} // object
  onLike={() =&gt; {}}         // function
/&gt;</code></pre>17:T493,<p><code>props.children</code> allows components to accept and render content passed between their opening and closing tags.</p>
<p><strong>Basic Usage</strong></p>
<div>
<div>
<div>&nbsp;</div>
</div>
<div>
<pre class="language-javascript"><code>function Card({ children }) {
  return (
    &lt;div className="card"&gt;
      {children}
    &lt;/div&gt;
  );
}

// Usage
&lt;Card&gt;
  &lt;h2&gt;Card Title&lt;/h2&gt;
  &lt;p&gt;Card content goes here&lt;/p&gt;
&lt;/Card&gt;</code></pre>
</div>
</div>
<p><strong>Composition Pattern</strong> Build flexible, reusable components by composing them together:</p>
<div>
<div>
<div>&nbsp;</div>
</div>
<div>
<pre class="language-javascript"><code>function Layout({ children }) {
  return (
    &lt;div className="layout"&gt;
      &lt;header&gt;My App&lt;/header&gt;
      &lt;main&gt;{children}&lt;/main&gt;
      &lt;footer&gt;&copy; 2024&lt;/footer&gt;
    &lt;/div&gt;
  );
}

function App() {
  return (
    &lt;Layout&gt;
      &lt;h1&gt;Welcome!&lt;/h1&gt;
      &lt;p&gt;This content goes in the main area&lt;/p&gt;
    &lt;/Layout&gt;
  );
}</code></pre>
</div>
</div>18:T564,<p><strong>Fragments (<code>&lt;&gt;...&lt;/&gt;</code>)</strong> Group multiple elements without adding extra DOM nodes:</p>
<div>
<div>
<div>
<div>
<pre class="language-javascript"><code>function List({ items }) {
  return (
    &lt;ul&gt;
      {items.map(item =&gt; (
        &lt;&gt;
          &lt;li&gt;{item.name}&lt;/li&gt;
          &lt;li&gt;{item.description}&lt;/li&gt;
        &lt;/&gt;
      ))}
    &lt;/ul&gt;
  );
}
</code></pre>
<p>If you need to assign a <strong>key</strong> to a fragment (e.g., inside <code>.map()</code>), you <strong>must</strong> use <code>React.Fragment</code>:</p>
<pre class="language-javascript"><code>function List({ items }) {
  return (
    &lt;ul&gt;
      {items.map(item =&gt; (
        &lt;React.Fragment key={item.id}&gt;
          &lt;li&gt;{item.name}&lt;/li&gt;
          &lt;li&gt;{item.description}&lt;/li&gt;
        &lt;/React.Fragment&gt;
      ))}
    &lt;/ul&gt;
  );
}
</code></pre>
</div>
</div>
</div>
<div>&nbsp;</div>
</div>
<p><strong>Self-Closing Tags</strong> JSX requires all tags to be properly closed:</p>
<pre class="language-javascript"><code>// ‚úÖ Correct
&lt;img src="photo.jpg" alt="Photo" /&gt;
&lt;input type="text" /&gt;
&lt;br /&gt;
&lt;hr /&gt;

// ‚ùå Wrong
&lt;img src="photo.jpg" alt="Photo"&gt;
&lt;input type="text"&gt;
&lt;br&gt;</code></pre>19:T46b,<p>Provide fallback values when props aren't passed:</p>
<p><strong>Using Default Parameters</strong></p>
<div>
<div>
<div>&nbsp;</div>
</div>
<div>
<pre class="language-javascript"><code>function Button({ text = "Click me", variant = "primary" }) {
  return (
    &lt;button className={`btn btn-${variant}`}&gt;
      {text}
    &lt;/button&gt;
  );
}

// Usage
&lt;Button /&gt;                              // Uses both defaults
&lt;Button text="Submit" /&gt;                // Uses variant default
&lt;Button text="Delete" variant="danger" /&gt; // No defaults used</code></pre>
</div>
</div>
<p><strong>Using Destructuring with Defaults</strong></p>
<pre class="language-javascript"><code>function UserCard({ 
  name = "Anonymous", 
  avatar = "/default-avatar.png",
  isOnline = false 
}) {
  return (
    &lt;div className="user-card"&gt;
      &lt;img src={avatar} alt={name} /&gt;
      &lt;h3&gt;{name}&lt;/h3&gt;
      &lt;span className={isOnline ? "online" : "offline"}&gt;
        {isOnline ? "üü¢" : "‚ö´"}
      &lt;/span&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<p>&nbsp;</p>1a:T5b5,<p>The Virtual DOM is React's strategy for efficient UI updates.</p>
<p><strong>How It Works</strong></p>
<ol>
<li><strong>Virtual Representation</strong>: React keeps a "virtual" copy of the DOM in memory</li>
<li><strong>Diffing</strong>: When state changes, React compares the new virtual DOM with the previous version</li>
<li><strong>Reconciliation</strong>: React calculates the minimum changes needed</li>
<li><strong>Efficient Updates</strong>: Only the changed parts are updated in the real DOM</li>
</ol>
<p><strong>Why It's Efficient</strong></p>
<pre class="language-javascript"><code>// When this state changes...
function Counter() {
  const [count, setCount] = useState(0);
  
  return (
    &lt;div&gt;
      &lt;h1&gt;My App&lt;/h1&gt;
      &lt;p&gt;Count: {count}&lt;/p&gt;  {/* Only this updates */}
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;+&lt;/button&gt;
      &lt;footer&gt;&copy; 2024&lt;/footer&gt;
    &lt;/div&gt;
  );
}</code></pre>
<p>React only updates the <code>&lt;p&gt;</code> element's text content, leaving everything else untouched. This is much faster than rebuilding the entire DOM.</p>
<p><strong>Benefits</strong></p>
<ul>
<li><strong>Performance</strong>: Minimizes expensive DOM operations</li>
<li><strong>Predictability</strong>: Declarative updates are easier to reason about</li>
<li><strong>Batching</strong>: Multiple state changes can be batched together</li>
</ul>1b:T73f,<h3>Reconciliation Algorithm</h3>
<p>React's reconciliation is the process of comparing (diffing) the current Virtual DOM tree with the previous one to determine what changes need to be made to the real DOM.</p>
<p><strong>The Diffing Strategy</strong> React uses heuristic algorithms based on two assumptions:</p>
<ol>
<li><strong>Different element types</strong> produce different trees</li>
<li><strong>Stable elements</strong> can be identified with a <code>key</code> prop</li>
</ol>
<p><strong>Element Type Changes</strong></p>
<div>
<div>
<div>&nbsp;</div>
</div>
<div>
<pre class="language-javascript"><code>// When this changes...
&lt;div&gt;
  &lt;Counter /&gt;
&lt;/div&gt;

// ...to this
&lt;span&gt;
  &lt;Counter /&gt;
&lt;/span&gt;

// React will:
// 1. Destroy the old &lt;div&gt; and Counter component
// 2. Create new &lt;span&gt; and Counter component
// 3. Counter loses all its state</code></pre>
</div>
</div>
<p><strong>Same Element Type</strong></p>
<div>
<div>
<div>&nbsp;</div>
</div>
<div>
<pre class="language-javascript"><code>// When this changes...
&lt;div className="before" title="stuff" /&gt;

// ...to this
&lt;div className="after" title="stuff" /&gt;

// React will:
// 1. Keep the same DOM node
// 2. Only update the className attribute</code></pre>
</div>
</div>
<p><strong>Component Updates</strong></p>
<div>
<div>
<div>&nbsp;</div>
</div>
<div>
<pre class="language-javascript"><code>function App() {
  const [count, setCount] = useState(0);
  
  return (
    &lt;div&gt;
      &lt;Counter count={count} /&gt;  {/* Same component, new props */}
    &lt;/div&gt;
  );
}

// React will:
// 1. Keep the Counter component instance
// 2. Update it with new props
// 3. Preserve component state (unless props cause re-render)</code></pre>
</div>
</div>1c:T589,<p>Fiber is React's reconciliation engine redesign that enables incremental rendering and better performance.</p>
<p><strong>Key Concepts</strong></p>
<ul>
<li><strong>Work Units</strong>: Each component update becomes a "unit of work"</li>
<li><strong>Interruptible</strong>: Work can be paused and resumed</li>
<li><strong>Priority-Based</strong>: High priority updates (user input) can interrupt low priority ones</li>
<li><strong>Time Slicing</strong>: Work is spread across multiple frames</li>
</ul>
<p><strong>How Fiber Works</strong></p>
<pre class="language-javascript"><code>// High priority update (user click)
function App() {
  const [urgent, setUrgent] = useState(0);
  const [heavy, setHeavy] = useState(0);
  
  return (
    &lt;div&gt;
      &lt;button onClick={() =&gt; setUrgent(urgent + 1)}&gt;
        Urgent: {urgent}  {/* This gets priority */}
      &lt;/button&gt;
      
      &lt;ExpensiveList data={heavy} /&gt;  {/* This can be interrupted */}
    &lt;/div&gt;
  );
}</code></pre>
<p><strong>Benefits of Fiber</strong></p>
<ul>
<li><strong>Responsiveness</strong>: UI stays responsive during heavy updates</li>
<li><strong>Smoother Animations</strong>: Better frame rate consistency</li>
<li><strong>Error Boundaries</strong>: Better error handling and recovery</li>
<li><strong>Concurrent Features</strong>: Enables Suspense, concurrent rendering</li>
</ul>1d:T823,<h3>Keys in Lists</h3>
<p>Keys help React identify which items have changed, been added, or removed in lists.</p>
<p><strong>Why Keys Matter</strong></p>
<pre class="language-javascript"><code>// ‚ùå Without keys - React doesn't know which item is which
function TodoList({ todos }) {
  return (
    &lt;ul&gt;
      {todos.map(todo =&gt; (
        &lt;li&gt;{todo.text}&lt;/li&gt;  // No key!
      ))}
    &lt;/ul&gt;
  );
}

// When an item is added at the beginning:
// React thinks all items changed and re-renders everything</code></pre>
<p><strong>Correct Key Usage</strong></p>
<pre class="language-javascript"><code>// ‚úÖ With stable keys
function TodoList({ todos }) {
  return (
    &lt;ul&gt;
      {todos.map(todo =&gt; (
        &lt;li key={todo.id}&gt;{todo.text}&lt;/li&gt;  // Unique, stable key
      ))}
    &lt;/ul&gt;
  );
}

// Now React knows exactly which item was added/removed/moved</code></pre>
<div>
<div>
<div>&nbsp;</div>
</div>
<div>&nbsp;</div>
</div>
<div>
<div>
<div>&nbsp;</div>
</div>
</div>
<p><strong>Key Guidelines</strong></p>
<div>
<div>
<div>&nbsp;</div>
</div>
<div>
<pre class="language-javascript"><code>// ‚úÖ Good: Stable, unique IDs
&lt;li key={item.id}&gt;{item.name}&lt;/li&gt;

// ‚ö†Ô∏è Acceptable: When no stable ID exists
&lt;li key={`${item.name}-${index}`}&gt;{item.name}&lt;/li&gt;

// ‚ùå Bad: Array index (causes issues with reordering)
&lt;li key={index}&gt;{item.name}&lt;/li&gt;

// ‚ùå Bad: Non-unique or unstable keys
&lt;li key={Math.random()}&gt;{item.name}&lt;/li&gt;</code></pre>
</div>
</div>
<p><strong>Impact on Component State</strong></p>
<div>
<div>
<pre class="language-javascript"><code>function UserList({ users }) {
  return (
    &lt;div&gt;
      {users.map(user =&gt; (
        &lt;UserProfile 
          key={user.id}  // Without this key, components
          user={user}    // might lose their internal state
        /&gt;               // when the list reorders
      ))}
    &lt;/div&gt;
  );
}</code></pre>
</div>
</div>1e:T8e7,<p>Understanding the distinction between these three concepts is crucial for advanced React development.</p>
<p><strong>Elements</strong> Plain JavaScript objects that describe what should appear on screen:</p>
<div>
<div>
<div>&nbsp;</div>
</div>
<div>
<pre class="language-javascript"><code>// This JSX...
&lt;Button color="blue"&gt;Click me&lt;/Button&gt;

// ...creates this element object:
{
  type: Button,
  props: {
    color: 'blue',
    children: 'Click me'
  }
}

// Elements are:
// - Immutable
// - Cheap to create
// - Descriptions, not instances</code></pre>
</div>
</div>
<p><strong>Components</strong> Functions or classes that return elements:</p>
<div>
<div>
<div>&nbsp;</div>
</div>
<div>
<pre class="language-javascript"><code>// Function component
function Button({ color, children }) {
  return (
    &lt;button style={{ color }}&gt;
      {children}
    &lt;/button&gt;
  );
}

// Class component
class Button extends React.Component {
  render() {
    return (
      &lt;button style={{ color: this.props.color }}&gt;
        {this.props.children}
      &lt;/button&gt;
    );
  }
}

// Components are:
// - Reusable templates
// - Can have state and lifecycle
// - Return elements from render</code></pre>
</div>
</div>
<p><strong>Instances</strong> The actual running "copies" of class components:</p>
<div>
<div>
<pre class="language-javascript"><code>lass Counter extends React.Component {
  constructor(props) {
    super(props);
    this.state = { count: 0 };  // Instance has its own state
  }
  
  render() {
    return &lt;div&gt;{this.state.count}&lt;/div&gt;;
  }
}

// When you use &lt;Counter /&gt;:
// - React creates an instance of the Counter class
// - Each instance has its own state and lifecycle
// - Functional components don't have instances (they're just called)</code></pre>
</div>
</div>
<p><strong>The Relationship</strong></p>
<pre class="language-javascript"><code>// 1. You write components
function App() {
  return &lt;Counter /&gt;;  // 2. Components return elements
}

// 3. React creates instances (for class components)
// 4. Instances render elements
// 5. Elements describe the DOM
// 6. React updates the DOM to match</code></pre>1f:T7a7,<p>State is data that can change over time in your React components. Unlike props (which come from parent components), state is <strong>owned and managed by the component itself</strong>.</p>
<p><strong>State vs Props</strong></p>
<pre class="language-javascript"><code>function UserProfile({ name }) {  // name is props (from parent)
  const [likes, setLikes] = useState(0);  // likes is state (owned by this component)
  
  return (
    &lt;div&gt;
      &lt;h2&gt;{name}&lt;/h2&gt;  {/* Can't change props */}
      &lt;p&gt;Likes: {likes}&lt;/p&gt;
      &lt;button onClick={() =&gt; setLikes(likes + 1)}&gt;  {/* Can change state */}
        üëç Like
      &lt;/button&gt;
    &lt;/div&gt;
  );
}</code></pre>
<p><strong>When UI Changes, State Changes</strong> State represents the "memory" of your component - data that can change and cause the component to re-render:</p>
<div>
<div>
<div>&nbsp;</div>
</div>
<div>
<pre class="language-javascript"><code>function Toggle() {
  const [isOn, setIsOn] = useState(false);  // State: can be true or false
  
  return (
    &lt;div&gt;
      &lt;p&gt;The light is {isOn ? 'ON' : 'OFF'}&lt;/p&gt;  {/* UI reflects state */}
      &lt;button onClick={() =&gt; setIsOn(!isOn)}&gt;
        Toggle
      &lt;/button&gt;
    &lt;/div&gt;
  );
}</code></pre>
</div>
</div>
<p><strong>State Triggers Re-renders</strong> When state changes, React automatically re-renders the component with the new data:</p>
<div>
<div>
<pre class="language-javascript"><code>function Counter() {
  const [count, setCount] = useState(0);
  
  console.log('Component rendered with count:', count);  // Logs on every render
  
  return (
    &lt;div&gt;
      &lt;p&gt;Count: {count}&lt;/p&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;  {/* Causes re-render */}
        Increment
      &lt;/button&gt;
    &lt;/div&gt;
  );
}

Local Co</code></pre>
</div>
</div>20:Tf28,<p>Local state belongs to a single component and doesn't need to be shared with other components.</p>
<p><strong>useState Hook&nbsp;</strong> The most common way to add state to functional components:</p>
<div>
<div>
<pre class="language-javascript"><code>import { useState } from 'react';

function ShoppingCart() {
  const [items, setItems] = useState([]);  // Array state
  const [isOpen, setIsOpen] = useState(false);  // Boolean state
  const [total, setTotal] = useState(0);  // Number state
  
  const addItem = (item) =&gt; {
    setItems([...items, item]);  // Update array state
    setTotal(total + item.price);
  };
  
  return (
    &lt;div&gt;
      &lt;button onClick={() =&gt; setIsOpen(!isOpen)}&gt;
        Cart ({items.length})
      &lt;/button&gt;
      {isOpen &amp;&amp; (
        &lt;div&gt;
          &lt;p&gt;Total: ${total}&lt;/p&gt;
          {items.map(item =&gt; (
            &lt;div key={item.id}&gt;{item.name} - ${item.price}&lt;/div&gt;
          ))}
        &lt;/div&gt;
      )}
    &lt;/div&gt;
  );
}</code></pre>
</div>
</div>
<p><strong>State is Isolated</strong> Each component instance has its own state:</p>
<div>
<div>
<pre class="language-javascript"><code>function App() {
  return (
    &lt;div&gt;
      &lt;Counter /&gt;  {/* Has its own count state */}
      &lt;Counter /&gt;  {/* Has its own separate count state */}
    &lt;/div&gt;
  );
}

function Counter() {
  const [count, setCount] = useState(0);  // Each instance starts at 0
  
  return (
    &lt;div&gt;
      &lt;p&gt;Count: {count}&lt;/p&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;+&lt;/button&gt;
    &lt;/div&gt;
  );
}</code></pre>
</div>
</div>
<p><strong>Multiple State Variables</strong> Components can have multiple pieces of state:</p>
<div>
<div>
<pre class="language-javascript"><code>function ProfileEditor() {
  const [name, setName] = useState('');
  const [email, setEmail] = useState('');
  const [bio, setBio] = useState('');
  const [isEditing, setIsEditing] = useState(false);
  
  const handleSave = () =&gt; {
    // Save profile data
    setIsEditing(false);
  };
  
  return (
    &lt;div&gt;
      {isEditing ? (
        &lt;form&gt;
          &lt;input 
            value={name} 
            onChange={(e) =&gt; setName(e.target.value)}
            placeholder="Name" 
          /&gt;
          &lt;input 
            value={email} 
            onChange={(e) =&gt; setEmail(e.target.value)}
            placeholder="Email" 
          /&gt;
          &lt;textarea 
            value={bio} 
            onChange={(e) =&gt; setBio(e.target.value)}
            placeholder="Bio" 
          /&gt;
          &lt;button onClick={handleSave}&gt;Save&lt;/button&gt;
        &lt;/form&gt;
      ) : (
        &lt;div&gt;
          &lt;h2&gt;{name}&lt;/h2&gt;
          &lt;p&gt;{email}&lt;/p&gt;
          &lt;p&gt;{bio}&lt;/p&gt;
          &lt;button onClick={() =&gt; setIsEditing(true)}&gt;Edit&lt;/button&gt;
        &lt;/div&gt;
      )}
    &lt;/div&gt;
  );
}</code></pre>
</div>
</div>
<p><strong>State Updates are Asynchronous</strong> State updates don't happen immediately - they're scheduled:</p>
<div>
<div>
<pre class="language-javascript"><code>function Example() {
  const [count, setCount] = useState(0);
  
  const handleClick = () =&gt; {
    console.log('Before:', count);  // Shows current value
    setCount(count + 1);
    console.log('After:', count);   // Still shows old value!
    
    // To use the new value immediately, use the functional update:
    setCount(prevCount =&gt; {
      console.log('New value:', prevCount + 1);
      return prevCount + 1;
    });
  };
  
  return &lt;button onClick={handleClick}&gt;Count: {count}&lt;/button&gt;;
}</code></pre>
</div>
</div>21:Tc07,<p>When multiple components need to share the same state, you "lift" the state to their closest common parent component.</p>
<p><strong>The Problem: Sibling Components Need Shared State</strong></p>
<pre class="language-javascript"><code>// ‚ùå These components can't communicate
function TemperatureInput() {
  const [temperature, setTemperature] = useState('');
  return &lt;input value={temperature} onChange={(e) =&gt; setTemperature(e.target.value)} /&gt;;
}

function TemperatureDisplay() {
  // How do we get the temperature from TemperatureInput?
  return &lt;p&gt;Temperature: ???&lt;/p&gt;;
}</code></pre>
<div>
<div>
<div>&nbsp;</div>
</div>
</div>
<p><strong>The Solution: Lift State to Common Parent</strong></p>
<pre class="language-javascript"><code>// ‚úÖ State lifted to parent, shared via props
function TemperatureConverter() {
  const [temperature, setTemperature] = useState('');
  
  return (
    &lt;div&gt;
      &lt;TemperatureInput 
        temperature={temperature} 
        onTemperatureChange={setTemperature} 
      /&gt;
      &lt;TemperatureDisplay temperature={temperature} /&gt;
    &lt;/div&gt;
  );
}

function TemperatureInput({ temperature, onTemperatureChange }) {
  return (
    &lt;input 
      value={temperature} 
      onChange={(e) =&gt; onTemperatureChange(e.target.value)} 
    /&gt;
  );
}

function TemperatureDisplay({ temperature }) {
  const celsius = temperature ? parseFloat(temperature) : 0;
  const fahrenheit = (celsius * 9/5) + 32;
  
  return (
    &lt;div&gt;
      &lt;p&gt;{celsius}&deg;C = {fahrenheit.toFixed(1)}&deg;F&lt;/p&gt;
    &lt;/div&gt;
  );
}</code></pre>
<div>
<div>
<div>&nbsp;</div>
</div>
</div>
<p><strong>Common Lifting Patterns</strong></p>
<pre class="language-javascript"><code>// Shopping cart example
function ShoppingApp() {
  const [cartItems, setCartItems] = useState([]);
  
  const addToCart = (product) =&gt; {
    setCartItems(prev =&gt; [...prev, { ...product, id: Date.now() }]);
  };
  
  const removeFromCart = (id) =&gt; {
    setCartItems(prev =&gt; prev.filter(item =&gt; item.id !== id));
  };
  
  return (
    &lt;div&gt;
      {/* Both components can access and modify cart */}
      &lt;ProductList onAddToCart={addToCart} /&gt;
      &lt;ShoppingCart items={cartItems} onRemoveItem={removeFromCart} /&gt;
      &lt;CartSummary itemCount={cartItems.length} /&gt;
    &lt;/div&gt;
  );
}</code></pre>
<p>&nbsp;</p>
<p><strong>Multi-Level Lifting</strong></p>
<pre class="language-javascript"><code>// Sometimes you need to lift state multiple levels up
function App() {
  const [user, setUser] = useState(null);
  
  return (
    &lt;div&gt;
      &lt;Header user={user} /&gt;
      &lt;Main user={user} onUserUpdate={setUser} /&gt;
    &lt;/div&gt;
  );
}

function Main({ user, onUserUpdate }) {
  return (
    &lt;div&gt;
      &lt;Sidebar user={user} /&gt;
      &lt;Content user={user} onUserUpdate={onUserUpdate} /&gt;
    &lt;/div&gt;
  );
}</code></pre>
<p>&nbsp;</p>22:Tda5,<h3>Colocation of State</h3>
<p>Keep state as close as possible to where it's actually used. Don't lift state higher than necessary.</p>
<p><strong>Principle: Start Local, Lift When Needed</strong></p>
<div>
<div>
<pre class="language-javascript"><code>// ‚úÖ Good: State stays local when only one component needs it
function UserProfile() {
  const [isEditing, setIsEditing] = useState(false);  // Only this component cares
  
  return (
    &lt;div&gt;
      {isEditing ? (
        &lt;EditForm onSave={() =&gt; setIsEditing(false)} /&gt;
      ) : (
        &lt;DisplayProfile onEdit={() =&gt; setIsEditing(true)} /&gt;
      )}
    &lt;/div&gt;
  );
}</code></pre>
</div>
</div>
<p><strong>Bad Colocation: State Too High</strong></p>
<div>
<div>
<pre class="language-javascript"><code>// ‚ùå Bad: Lifting state unnecessarily
function App() {
  const [isModalOpen, setIsModalOpen] = useState(false);  // Only used in Settings
  const [isEditing, setIsEditing] = useState(false);     // Only used in Profile
  const [searchTerm, setSearchTerm] = useState('');      // Only used in Search
  
  return (
    &lt;div&gt;
      &lt;Header /&gt;
      &lt;Profile isEditing={isEditing} setIsEditing={setIsEditing} /&gt;
      &lt;Settings isModalOpen={isModalOpen} setIsModalOpen={setIsModalOpen} /&gt;
      &lt;Search searchTerm={searchTerm} setSearchTerm={setSearchTerm} /&gt;
    &lt;/div&gt;
  );
}</code></pre>
</div>
</div>
<p><strong>Good Colocation: State Where It's Needed</strong></p>
<div>
<div>
<pre class="language-javascript"><code>// ‚úÖ Good: Each component manages its own local state
function App() {
  return (
    &lt;div&gt;
      &lt;Header /&gt;
      &lt;Profile /&gt;    {/* Manages its own editing state */}
      &lt;Settings /&gt;   {/* Manages its own modal state */}
      &lt;Search /&gt;     {/* Manages its own search state */}
    &lt;/div&gt;
  );
}

function Profile() {
  const [isEditing, setIsEditing] = useState(false);  // Colocated with usage
  // ... component logic
}

function Settings() {
  const [isModalOpen, setIsModalOpen] = useState(false);  // Colocated with usage
  // ... component logic
}</code></pre>
</div>
</div>
<p><strong>Balancing Act: Shared vs Local</strong></p>
<pre class="language-javascript"><code>function BlogPost() {
  // Shared state: multiple components need this
  const [post, setPost] = useState(null);
  const [comments, setComments] = useState([]);
  
  return (
    &lt;article&gt;
      &lt;PostHeader post={post} /&gt;
      &lt;PostContent post={post} /&gt;
      &lt;CommentSection comments={comments} onAddComment={addComment} /&gt;
      &lt;ShareButtons post={post} /&gt;  {/* Needs post data */}
    &lt;/article&gt;
  );
}

function CommentSection({ comments, onAddComment }) {
  // Local state: only this component cares about the form
  const [newComment, setNewComment] = useState('');
  const [isSubmitting, setIsSubmitting] = useState(false);
  
  const handleSubmit = async () =&gt; {
    setIsSubmitting(true);
    await onAddComment(newComment);
    setNewComment('');  // Clear form
    setIsSubmitting(false);
  };
  
  return (
    &lt;div&gt;
      &lt;CommentList comments={comments} /&gt;
      &lt;CommentForm 
        value={newComment}
        onChange={setNewComment}
        onSubmit={handleSubmit}
        isSubmitting={isSubmitting}
      /&gt;
    &lt;/div&gt;
  );
}</code></pre>23:T189a,<p>Managing form data is one of the most common uses of state in React applications.</p>
<p><strong>Controlled Components</strong> React controls the form element's value through state:</p>
<pre class="language-javascript"><code>function ContactForm() {
  const [formData, setFormData] = useState({
    name: '',
    email: '',
    message: ''
  });
  
  const handleChange = (e) =&gt; {
    const { name, value } = e.target;
    setFormData(prev =&gt; ({
      ...prev,
      [name]: value
    }));
  };
  
  const handleSubmit = (e) =&gt; {
    e.preventDefault();
    console.log('Form submitted:', formData);
  };
  
  return (
    &lt;form onSubmit={handleSubmit}&gt;
      &lt;input
        name="name"
        value={formData.name}
        onChange={handleChange}
        placeholder="Your name"
      /&gt;
      &lt;input
        name="email"
        type="email"
        value={formData.email}
        onChange={handleChange}
        placeholder="Your email"
      /&gt;
      &lt;textarea
        name="message"
        value={formData.message}
        onChange={handleChange}
        placeholder="Your message"
      /&gt;
      &lt;button type="submit"&gt;Send&lt;/button&gt;
    &lt;/form&gt;
  );
}</code></pre>
<p><strong>Individual State Variables</strong>&nbsp;For simpler forms, you can use separate state variables:</p>
<pre class="language-javascript"><code>function LoginForm() {
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  const [rememberMe, setRememberMe] = useState(false);
  
  const handleSubmit = (e) =&gt; {
    e.preventDefault();
    login({ username, password, rememberMe });
  };
  
  return (
    &lt;form onSubmit={handleSubmit}&gt;
      &lt;input
        type="text"
        value={username}
        onChange={(e) =&gt; setUsername(e.target.value)}
        placeholder="Username"
      /&gt;
      &lt;input
        type="password"
        value={password}
        onChange={(e) =&gt; setPassword(e.target.value)}
        placeholder="Password"
      /&gt;
      &lt;label&gt;
        &lt;input
          type="checkbox"
          checked={rememberMe}
          onChange={(e) =&gt; setRememberMe(e.target.checked)}
        /&gt;
        Remember me
      &lt;/label&gt;
      &lt;button type="submit"&gt;Login&lt;/button&gt;
    &lt;/form&gt;
  );
}</code></pre>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><strong>Form Validation State :</strong></p>
<pre class="language-javascript"><code>function RegistrationForm() {
  const [formData, setFormData] = useState({
    username: '',
    email: '',
    password: '',
    confirmPassword: ''
  });
  
  const [errors, setErrors] = useState({});
  const [isSubmitting, setIsSubmitting] = useState(false);
  
  const validateField = (name, value) =&gt; {
    switch (name) {
      case 'username':
        return value.length &lt; 3 ? 'Username must be at least 3 characters' : '';
      case 'email':
        return !value.includes('@') ? 'Please enter a valid email' : '';
      case 'password':
        return value.length &lt; 6 ? 'Password must be at least 6 characters' : '';
      case 'confirmPassword':
        return value !== formData.password ? 'Passwords do not match' : '';
      default:
        return '';
    }
  };
  
  const handleChange = (e) =&gt; {
    const { name, value } = e.target;
    
    setFormData(prev =&gt; ({ ...prev, [name]: value }));
    
    // Clear error when user starts typing
    if (errors[name]) {
      setErrors(prev =&gt; ({ ...prev, [name]: '' }));
    }
  };
  
  const handleBlur = (e) =&gt; {
    const { name, value } = e.target;
    const error = validateField(name, value);
    setErrors(prev =&gt; ({ ...prev, [name]: error }));
  };
  
  const handleSubmit = async (e) =&gt; {
    e.preventDefault();
    
    // Validate all fields
    const newErrors = {};
    Object.keys(formData).forEach(key =&gt; {
      const error = validateField(key, formData[key]);
      if (error) newErrors[key] = error;
    });
    
    if (Object.keys(newErrors).length &gt; 0) {
      setErrors(newErrors);
      return;
    }
    
    setIsSubmitting(true);
    try {
      await registerUser(formData);
      // Handle success
    } catch (error) {
      setErrors({ submit: error.message });
    } finally {
      setIsSubmitting(false);
    }
  };
  
  return (
    &lt;form onSubmit={handleSubmit}&gt;
      &lt;div&gt;
        &lt;input
          name="username"
          value={formData.username}
          onChange={handleChange}
          onBlur={handleBlur}
          placeholder="Username"
        /&gt;
        {errors.username &amp;&amp; &lt;span className="error"&gt;{errors.username}&lt;/span&gt;}
      &lt;/div&gt;
      
      &lt;div&gt;
        &lt;input
          name="email"
          type="email"
          value={formData.email}
          onChange={handleChange}
          onBlur={handleBlur}
          placeholder="Email"
        /&gt;
        {errors.email &amp;&amp; &lt;span className="error"&gt;{errors.email}&lt;/span&gt;}
      &lt;/div&gt;
      
      &lt;div&gt;
        &lt;input
          name="password"
          type="password"
          value={formData.password}
          onChange={handleChange}
          onBlur={handleBlur}
          placeholder="Password"
        /&gt;
        {errors.password &amp;&amp; &lt;span className="error"&gt;{errors.password}&lt;/span&gt;}
      &lt;/div&gt;
      
      &lt;div&gt;
        &lt;input
          name="confirmPassword"
          type="password"
          value={formData.confirmPassword}
          onChange={handleChange}
          onBlur={handleBlur}
          placeholder="Confirm Password"
        /&gt;
        {errors.confirmPassword &amp;&amp; &lt;span className="error"&gt;{errors.confirmPassword}&lt;/span&gt;}
      &lt;/div&gt;
      
      {errors.submit &amp;&amp; &lt;div className="error"&gt;{errors.submit}&lt;/div&gt;}
      
      &lt;button type="submit" disabled={isSubmitting}&gt;
        {isSubmitting ? 'Registering...' : 'Register'}
      &lt;/button&gt;
    &lt;/form&gt;
  );
}</code></pre>
<p>&nbsp;</p>24:T1a94,<p>In React, state should never be mutated directly. Instead, you create new objects/arrays with the desired changes.</p>
<p><strong>Why Immutability Matters</strong> React uses Object.is() comparison to detect state changes. If you mutate state directly, React won't detect the change:</p>
<pre class="language-javascript"><code>In React, state should never be mutated directly. Instead, you create new objects/arrays with the desired changes.
Why Immutability Matters
React uses Object.is() comparison to detect state changes. If you mutate state directly, React won't detect the change:
jsxfunction TodoList() {
  const [todos, setTodos] = useState([]);
  
  const addTodo = (text) =&gt; {
    // ‚ùå Wrong - mutates existing array
    todos.push({ id: Date.now(), text, done: false });
    setTodos(todos);  // React won't re-render!
    
    // ‚úÖ Correct - creates new array
    setTodos([...todos, { id: Date.now(), text, done: false }]);
  };
}
Array Update Patterns
jsxfunction TodoApp() {
  const [todos, setTodos] = useState([
    { id: 1, text: 'Learn React', done: false },
    { id: 2, text: 'Build an app', done: false }
  ]);
  
  // Add item
  const addTodo = (text) =&gt; {
    setTodos([...todos, { id: Date.now(), text, done: false }]);
  };
  
  // Remove item
  const removeTodo = (id) =&gt; {
    setTodos(todos.filter(todo =&gt; todo.id !== id));
  };
  
  // Update item
  const toggleTodo = (id) =&gt; {
    setTodos(todos.map(todo =&gt; 
      todo.id === id 
        ? { ...todo, done: !todo.done }  // Create new object
        : todo  // Keep existing object
    ));
  };
  
  // Insert at specific position
  const insertTodoAt = (index, newTodo) =&gt; {
    setTodos([
      ...todos.slice(0, index),
      newTodo,
      ...todos.slice(index)
    ]);
  };
}
Object Update Patterns
jsxfunction UserProfile() {
  const [user, setUser] = useState({
    name: 'John',
    email: 'john@example.com',
    preferences: {
      theme: 'dark',
      notifications: true
    }
  });
  
  // Update top-level property
  const updateName = (newName) =&gt; {
    setUser({ ...user, name: newName });
  };
  
  // Update nested property
  const updateTheme = (newTheme) =&gt; {
    setUser({
      ...user,
      preferences: {
        ...user.preferences,
        theme: newTheme
      }
    });
  };
  
  // Update multiple properties
  const updateProfile = (updates) =&gt; {
    setUser({ ...user, ...updates });
  };
}
Complex State Updates with useReducer
For complex state logic, useReducer can be clearer:
jsxconst todoReducer = (state, action) =&gt; {
  switch (action.type) {
    case 'ADD_TODO':
      return [...state, { id: Date.now(), text: action.text, done: false }];
    
    case 'TOGGLE_TODO':
      return state.map(todo =&gt;
        todo.id === action.id ? { ...todo, done: !todo.done } : todo
      );
    
    case 'DELETE_TODO':
      return state.filter(todo =&gt; todo.id !== action.id);
    
    default:
      return state;
  }
};

function TodoList() {
  const [todos, dispatch] = useReducer(todoReducer, []);
  
  return (
    &lt;div&gt;
      &lt;button onClick={() =&gt; dispatch({ type: 'ADD_TODO', text: 'New task' })}&gt;
        Add Todo
      &lt;/button&gt;
      {todos.map(todo =&gt; (
        &lt;div key={todo.id}&gt;
          &lt;span onClick={() =&gt; dispatch({ type: 'TOGGLE_TODO', id: todo.id })}&gt;
            {todo.done ? '‚úÖ' : '‚¨ú'} {todo.text}
          &lt;/span&gt;
          &lt;button onClick={() =&gt; dispatch({ type: 'DELETE_TODO', id: todo.id })}&gt;
            Delete
          &lt;/button&gt;
        &lt;/div&gt;
      ))}
    &lt;/div&gt;
  );
}</code></pre>
<p>&nbsp;</p>
<p><strong>Array Update Patterns</strong></p>
<pre class="language-javascript"><code>function TodoApp() {
  const [todos, setTodos] = useState([
    { id: 1, text: 'Learn React', done: false },
    { id: 2, text: 'Build an app', done: false }
  ]);
  
  // Add item
  const addTodo = (text) =&gt; {
    setTodos([...todos, { id: Date.now(), text, done: false }]);
  };
  
  // Remove item
  const removeTodo = (id) =&gt; {
    setTodos(todos.filter(todo =&gt; todo.id !== id));
  };
  
  // Update item
  const toggleTodo = (id) =&gt; {
    setTodos(todos.map(todo =&gt; 
      todo.id === id 
        ? { ...todo, done: !todo.done }  // Create new object
        : todo  // Keep existing object
    ));
  };
  
  // Insert at specific position
  const insertTodoAt = (index, newTodo) =&gt; {
    setTodos([
      ...todos.slice(0, index),
      newTodo,
      ...todos.slice(index)
    ]);
  };
}</code></pre>
<p><strong>Object Update Patterns</strong></p>
<pre class="language-javascript"><code>function UserProfile() {
  const [user, setUser] = useState({
    name: 'John',
    email: 'john@example.com',
    preferences: {
      theme: 'dark',
      notifications: true
    }
  });
  
  // Update top-level property
  const updateName = (newName) =&gt; {
    setUser({ ...user, name: newName });
  };
  
  // Update nested property
  const updateTheme = (newTheme) =&gt; {
    setUser({
      ...user,
      preferences: {
        ...user.preferences,
        theme: newTheme
      }
    });
  };
  
  // Update multiple properties
  const updateProfile = (updates) =&gt; {
    setUser({ ...user, ...updates });
  };
}</code></pre>
<p><strong>Complex State Updates with useReducer</strong>&nbsp;For complex state logic, useReducer can be clearer:</p>
<pre class="language-javascript"><code>const todoReducer = (state, action) =&gt; {
  switch (action.type) {
    case 'ADD_TODO':
      return [...state, { id: Date.now(), text: action.text, done: false }];
    
    case 'TOGGLE_TODO':
      return state.map(todo =&gt;
        todo.id === action.id ? { ...todo, done: !todo.done } : todo
      );
    
    case 'DELETE_TODO':
      return state.filter(todo =&gt; todo.id !== action.id);
    
    default:
      return state;
  }
};

function TodoList() {
  const [todos, dispatch] = useReducer(todoReducer, []);
  
  return (
    &lt;div&gt;
      &lt;button onClick={() =&gt; dispatch({ type: 'ADD_TODO', text: 'New task' })}&gt;
        Add Todo
      &lt;/button&gt;
      {todos.map(todo =&gt; (
        &lt;div key={todo.id}&gt;
          &lt;span onClick={() =&gt; dispatch({ type: 'TOGGLE_TODO', id: todo.id })}&gt;
            {todo.done ? '‚úÖ' : '‚¨ú'} {todo.text}
          &lt;/span&gt;
          &lt;button onClick={() =&gt; dispatch({ type: 'DELETE_TODO', id: todo.id })}&gt;
            Delete
          &lt;/button&gt;
        &lt;/div&gt;
      ))}
    &lt;/div&gt;
  );
}</code></pre>25:Tb67,<p>The Context API allows you to share data across many components without manually passing props through every level.</p>
<p><strong>When to Use Context</strong></p>
<pre class="language-javascript"><code>// ‚ùå Prop drilling problem
function App() {
  const [user, setUser] = useState({ name: 'John', role: 'admin' });
  
  return &lt;Layout user={user} setUser={setUser} /&gt;;
}

function Layout({ user, setUser }) {
  return (
    &lt;div&gt;
      &lt;Header user={user} setUser={setUser} /&gt;
      &lt;Main user={user} /&gt;
    &lt;/div&gt;
  );
}

function Header({ user, setUser }) {
  return &lt;UserMenu user={user} setUser={setUser} /&gt;;
}

function UserMenu({ user, setUser }) {
  return &lt;div&gt;Welcome, {user.name}!&lt;/div&gt;;
}</code></pre>
<p><strong>Creating and Using Context</strong></p>
<pre class="language-javascript"><code>// 1. Create Context
const UserContext = createContext();

// 2. Create Provider Component
function UserProvider({ children }) {
  const [user, setUser] = useState({ name: 'John', role: 'admin' });
  
  const value = {
    user,
    setUser,
    isAdmin: user.role === 'admin'
  };
  
  return (
    &lt;UserContext.Provider value={value}&gt;
      {children}
    &lt;/UserContext.Provider&gt;
  );
}

// 3. Use in App
function App() {
  return (
    &lt;UserProvider&gt;
      &lt;Layout /&gt;
    &lt;/UserProvider&gt;
  );
}

// 4. Consume Context (without useContext hook yet)
function UserMenu() {
  return (
    &lt;UserContext.Consumer&gt;
      {({ user, setUser, isAdmin }) =&gt; (
        &lt;div&gt;
          &lt;p&gt;Welcome, {user.name}!&lt;/p&gt;
          {isAdmin &amp;&amp; &lt;AdminPanel /&gt;}
          &lt;button onClick={() =&gt; setUser({ ...user, name: 'Jane' })}&gt;
            Change Name
          &lt;/button&gt;
        &lt;/div&gt;
      )}
    &lt;/UserContext.Consumer&gt;
  );
}</code></pre>
<p><strong>Context Best Practices</strong></p>
<pre class="language-javascript"><code>// Split contexts by concern
const AuthContext = createContext();  // User authentication
const ThemeContext = createContext(); // UI theme
const CartContext = createContext();  // Shopping cart

// Provide default values
const ThemeContext = createContext({
  theme: 'light',
  toggleTheme: () =&gt; {}
});

// Create custom provider with logic
function ThemeProvider({ children }) {
  const [theme, setTheme] = useState('light');
  
  const toggleTheme = () =&gt; {
    setTheme(prev =&gt; prev === 'light' ? 'dark' : 'light');
  };
  
  const value = {
    theme,
    toggleTheme,
    colors: theme === 'light' ? lightColors : darkColors
  };
  
  return (
    &lt;ThemeContext.Provider value={value}&gt;
      &lt;div className={`app-${theme}`}&gt;
        {children}
      &lt;/div&gt;
    &lt;/ThemeContext.Provider&gt;
  );
}</code></pre>26:T10f7,<p>Different state management approaches work better for different scenarios.</p>
<p><strong>useState - Simple Local State</strong> Use for simple, independent pieces of state:</p>
<div>
<div>
<div>&nbsp;</div>
</div>
<div>
<pre class="language-javascript"><code>function Counter() {
  const [count, setCount] = useState(0);  // Simple number
  const [isVisible, setIsVisible] = useState(true);  // Simple boolean
  
  return (
    &lt;div&gt;
      {isVisible &amp;&amp; &lt;p&gt;Count: {count}&lt;/p&gt;}
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;+&lt;/button&gt;
      &lt;button onClick={() =&gt; setIsVisible(!isVisible)}&gt;Toggle&lt;/button&gt;
    &lt;/div&gt;
  );
}</code></pre>
</div>
</div>
<p><strong>useReducer - Complex State Logic</strong> Use when state updates involve complex logic or multiple related values:</p>
<div>
<div>
<div>&nbsp;</div>
</div>
<div>
<pre class="language-javascript"><code>const formReducer = (state, action) =&gt; {
  switch (action.type) {
    case 'SET_FIELD':
      return {
        ...state,
        values: { ...state.values, [action.field]: action.value },
        errors: { ...state.errors, [action.field]: null }  // Clear error
      };
    
    case 'SET_ERROR':
      return {
        ...state,
        errors: { ...state.errors, [action.field]: action.error }
      };
    
    case 'SUBMIT_START':
      return { ...state, isSubmitting: true, submitError: null };
    
    case 'SUBMIT_SUCCESS':
      return { values: {}, errors: {}, isSubmitting: false, submitError: null };
    
    case 'SUBMIT_ERROR':
      return { ...state, isSubmitting: false, submitError: action.error };
    
    default:
      return state;
  }
};

function ContactForm() {
  const [state, dispatch] = useReducer(formReducer, {
    values: { name: '', email: '', message: '' },
    errors: {},
    isSubmitting: false,
    submitError: null
  });
  
  const handleSubmit = async (e) =&gt; {
    e.preventDefault();
    dispatch({ type: 'SUBMIT_START' });
    
    try {
      await submitForm(state.values);
      dispatch({ type: 'SUBMIT_SUCCESS' });
    } catch (error) {
      dispatch({ type: 'SUBMIT_ERROR', error: error.message });
    }
  };
  
  return (
    &lt;form onSubmit={handleSubmit}&gt;
      &lt;input
        value={state.values.name}
        onChange={(e) =&gt; dispatch({ 
          type: 'SET_FIELD', 
          field: 'name', 
          value: e.target.value 
        })}
      /&gt;
      {state.errors.name &amp;&amp; &lt;span&gt;{state.errors.name}&lt;/span&gt;}
      {/* More fields... */}
    &lt;/form&gt;
  );
}</code></pre>
</div>
</div>
<p><strong>Lifting State Up - Shared State</strong> Use when multiple components need the same state:</p>
<div>
<div>
<div>&nbsp;</div>
</div>
<div>
<pre class="language-javascript"><code>// State lifted to common parent
function ShoppingApp() {
  const [cartItems, setCartItems] = useState([]);
  const [products, setProducts] = useState([]);
  
  const addToCart = (product) =&gt; {
    setCartItems([...cartItems, product]);
  };
  
  const removeFromCart = (productId) =&gt; {
    setCartItems(cartItems.filter(item =&gt; item.id !== productId));
  };
  
  return (
    &lt;div&gt;
      &lt;Header cartCount={cartItems.length} /&gt;
      &lt;ProductList 
        products={products} 
        onAddToCart={addToCart} 
      /&gt;
      &lt;Cart 
        items={cartItems} 
        onRemoveItem={removeFromCart} 
      /&gt;
    &lt;/div&gt;
  );
}</code></pre>
</div>
</div>
<p><strong>Decision Matrix</strong></p>
<pre class="language-javascript"><code>// ‚úÖ useState when:
// - Simple, independent state
// - Single component needs it
// - Basic data types (string, number, boolean)

// ‚úÖ useReducer when:
// - Complex state logic
// - Multiple related state values
// - State updates depend on previous state
// - Want to centralize state logic

// ‚úÖ Lifting state up when:
// - Multiple components need same data
// - Components need to sync state
// - Parent needs to control child state

// ‚úÖ Context when:
// - Many deeply nested components need data
// - Prop drilling becomes cumbersome
// - Global or semi-global state (theme, auth, etc.)</code></pre>27:T61e,<p>Think of React components like a butterfly's life cycle - they're born, they grow and change, and eventually they disappear! ü¶ã</p>
<h4><strong>Mount Phase</strong> üìç</h4>
<p>When your component appears for the first time:</p>
<pre class="language-javascript"><code>function WelcomeMessage() {
  // This runs when component first appears
  useEffect(() =&gt; {
    console.log("Hello! I just mounted! üëã");
  }, []); // Empty array = only on mount
  
  return &lt;h1&gt;Welcome to our app!&lt;/h1&gt;;
}</code></pre>
<h4><strong>Update Phase</strong> üîÑ</h4>
<p>When your component changes (props or state update):</p>
<pre class="language-javascript"><code>function Counter() {
  const [count, setCount] = useState(0);
  
  // This runs every time count changes
  useEffect(() =&gt; {
    console.log(`Count updated to: ${count} üìä`);
  }, [count]); // Runs when count changes
  
  return (
    &lt;button onClick={() =&gt; setCount(count + 1)}&gt;
      Count: {count}
    &lt;/button&gt;
  );
}</code></pre>
<h4><strong>Unmount Phase</strong> üö™</h4>
<p>When your component is about to disappear:</p>
<pre class="language-javascript"><code>function Timer() {
  useEffect(() =&gt; {
    const timer = setInterval(() =&gt; {
      console.log("Tick! ‚è∞");
    }, 1000);
    
    // Cleanup before component leaves
    return () =&gt; {
      clearInterval(timer);
      console.log("Timer cleaned up! Goodbye! üëã");
    };
  }, []);
  
  return &lt;div&gt;Timer is running...&lt;/div&gt;;
}</code></pre>28:T6b8,<p>Always clean up after yourself! It's like washing dishes after cooking - necessary to avoid problems.</p>
<h4><strong>Why Cleanup Matters:</strong></h4>
<ul>
<li>Prevents memory leaks üï≥Ô∏è</li>
<li>Stops unwanted subscriptions üì°</li>
<li>Cancels pending requests üö´</li>
</ul>
<pre class="language-javascript"><code>function ChatRoom({ roomId }) {
  const [messages, setMessages] = useState([]);
  
  useEffect(() =&gt; {
    // Setup: Subscribe to chat
    const unsubscribe = chatAPI.subscribe(roomId, (newMessage) =&gt; {
      setMessages(prev =&gt; [...prev, newMessage]);
    });
    
    // Cleanup: Unsubscribe when component unmounts or roomId changes
    return () =&gt; {
      unsubscribe();
      console.log(`Left room ${roomId} üö™`);
    };
  }, [roomId]);
  
  return (
    &lt;div&gt;
      {messages.map(msg =&gt; &lt;p key={msg.id}&gt;{msg.text}&lt;/p&gt;)}
    &lt;/div&gt;
  );
}</code></pre>
<h4><strong>Common Cleanup Patterns:</strong></h4>
<pre class="language-javascript"><code>useEffect(() =&gt; {
  // Timer cleanup
  const timer = setTimeout(() =&gt; {}, 1000);
  return () =&gt; clearTimeout(timer);
}, []);

useEffect(() =&gt; {
  // Event listener cleanup
  const handleScroll = () =&gt; {};
  window.addEventListener('scroll', handleScroll);
  return () =&gt; window.removeEventListener('scroll', handleScroll);
}, []);

useEffect(() =&gt; {
  // AbortController for fetch cleanup
  const controller = new AbortController();
  
  fetch('/api/data', { signal: controller.signal })
    .then(response =&gt; response.json())
    .then(data =&gt; setData(data));
    
  return () =&gt; controller.abort();
}, []);</code></pre>29:T90e,<p><strong>The Problem:</strong> What if a slow API call finishes after the component has moved on?</p>
<div>
<div>
<div>&nbsp;</div>
</div>
<div>
<pre class="language-javascript"><code>// ‚ùå PROBLEM: Race condition disaster!
function UserProfile({ userId }) {
  const [user, setUser] = useState(null);
  
  useEffect(() =&gt; {
    async function fetchUser() {
      const response = await fetch(`/api/users/${userId}`);
      const userData = await response.json();
      // What if userId changed while we were fetching? üò±
      setUser(userData); // This might be the wrong user!
    }
    
    fetchUser();
  }, [userId]);
  
  return &lt;div&gt;{user?.name}&lt;/div&gt;;
}</code></pre>
</div>
</div>
<p><strong>‚úÖ SOLUTION: Ignore stale requests</strong></p>
<div>
<pre class="language-javascript"><code>function UserProfile({ userId }) {
  const [user, setUser] = useState(null);
  
  useEffect(() =&gt; {
    let ignore = false; // Flag to track if effect is stale
    
    async function fetchUser() {
      const response = await fetch(`/api/users/${userId}`);
      const userData = await response.json();
      
      // Only update if this effect is still relevant
      if (!ignore) {
        setUser(userData);
      }
    }
    
    fetchUser();
    
    // Cleanup: Mark this effect as stale
    return () =&gt; {
      ignore = true;
    };
  }, [userId]);
  
  return &lt;div&gt;{user?.name}&lt;/div&gt;;
}</code></pre>
</div>
<p><strong>üöÄ BETTER: Using AbortController (React 19 style)</strong></p>
<pre class="language-javascript"><code>function UserProfile({ userId }) {
  const [user, setUser] = useState(null);
  
  useEffect(() =&gt; {
    const controller = new AbortController();
    
    async function fetchUser() {
      try {
        const response = await fetch(`/api/users/${userId}`, {
          signal: controller.signal
        });
        const userData = await response.json();
        setUser(userData);
      } catch (error) {
        if (error.name !== 'AbortError') {
          console.error('Fetch failed:', error);
        }
      }
    }
    
    fetchUser();
    
    return () =&gt; controller.abort();
  }, [userId]);
  
  return &lt;div&gt;{user?.name}&lt;/div&gt;;
}</code></pre>2a:T762,<p>React 19 is super smart about when and how it runs your effects!</p>
<h4><strong>Automatic Batching</strong></h4>
<p>Multiple state updates get batched together for better performance:</p>
<div>
<div>
<div>&nbsp;</div>
</div>
<div>
<pre class="language-javascript"><code>function App() {
  const [count, setCount] = useState(0);
  const [flag, setFlag] = useState(false);
  
  function handleClick() {
    // React 19 batches these automatically! üéØ
    setCount(c =&gt; c + 1);
    setFlag(f =&gt; !f);
    // Only ONE re-render happens, not two!
  }
  
  useEffect(() =&gt; {
    console.log('Effect runs once for both updates! ‚ö°');
  }, [count, flag]);
  
  return &lt;button onClick={handleClick}&gt;Update both!&lt;/button&gt;;
}</code></pre>
</div>
</div>
<h4><strong>Effect Timing Control</strong></h4>
<div>
<div>
<div>&nbsp;</div>
</div>
<div>
<pre class="language-javascript"><code>function TimingExample() {
  const [data, setData] = useState(null);
  
  // Regular effect - runs after render
  useEffect(() =&gt; {
    console.log('1. This runs after DOM update üé®');
  });
  
  // Layout effect - runs before browser paint
  useLayoutEffect(() =&gt; {
    console.log('2. This runs before browser paint üèóÔ∏è');
    // Use for DOM measurements or immediate DOM changes
  });
  
  return &lt;div&gt;Check the console for timing! ‚è∞&lt;/div&gt;;
}</code></pre>
</div>
</div>
<h4><strong>Pro Tips for React 19:</strong> üéØ</h4>
<ul>
<li>Use <code>use()</code> hook for async data fetching (new in React 19!)</li>
<li>Leverage automatic batching - don't worry about multiple setState calls</li>
<li>Clean up effects properly to avoid memory leaks</li>
<li>Use AbortController for cancelling async operations</li>
<li>Consider useLayoutEffect only when you need to measure or modify DOM before paint</li>
</ul>2b:T4b3,<p><strong>The Golden Rules (Never Break These!):</strong></p>
<ol>
<li><strong>Only call hooks at the top level</strong> üîù</li>
</ol>
<div>
<div>
<pre class="language-javascript"><code>function Component() {
  const [state, setState] = useState(0); // Hook at the top level - React can track it ‚ú®
  
  return &lt;div&gt;{state}&lt;/div&gt;; // Return JSX to display the state
}

// ‚ùå BAD
function Component() {
  if (true) { // Don't put hooks inside conditions
    const [state, setState] = useState(0); // React gets confused! ‚ùå
  }
}</code></pre>
</div>
</div>
<ol start="2">
<li><strong>Only call hooks from React functions</strong> ‚öõÔ∏è</li>
</ol>
<pre class="language-javascript"><code>// ‚úÖ GOOD - Inside React component
function MyComponent() {
  const [count, setCount] = useState(0); // Hook inside React component - perfect! ‚ú®
}

// ‚úÖ GOOD - Inside custom hook
function useCounter() {
  const [count, setCount] = useState(0); // Hook inside custom hook - also good! ‚ú®
}

// ‚ùå BAD - Regular JavaScript function
function regularFunction() {
  const [count, setCount] = useState(0); // Regular function can't use hooks! ‚ùå
}</code></pre>2c:T537,<p>Do stuff <strong>after</strong> your component renders! Like a helpful assistant.</p>
<pre class="language-javascript"><code>function Welcome() {
  useEffect(() =&gt; { // This function runs after component renders
    console.log("Component just appeared! üëã"); // Log message to console
  }, []); // Empty array means "only run once when component first appears"
  
  return &lt;h1&gt;Welcome!&lt;/h1&gt;; // Return JSX to display
}</code></pre>
<p><strong>Common patterns:</strong></p>
<pre class="language-javascript"><code>// Run every render
useEffect(() =&gt; { // This function runs after every render
  console.log("I run every time! üîÑ"); // Log message every time
}); // No dependency array = runs every time

// Run only when 'count' changes
useEffect(() =&gt; { // This function runs when count changes
  console.log("Count changed! üìä"); // Log when count updates
}, [count]); // Array with count = only run when count changes

// Cleanup when leaving
useEffect(() =&gt; { // This function runs once when component appears
  const timer = setInterval(() =&gt; {}, 1000); // Create a timer that runs every second
  return () =&gt; clearInterval(timer); // Return cleanup function to stop timer
}, []); // Empty array = run once, cleanup when component disappears</code></pre>
<p>&nbsp;</p>2d:T476,<p>Show optimistic updates while waiting for server! Instant UI feedback.</p>
<div>
<div>
<div>&nbsp;</div>
</div>
<div>
<pre class="language-javascript"><code>function TodoList({ todos }) {
  const [optimisticTodos, addOptimisticTodo] = useOptimistic(
    todos, // Current todos from server
    (state, newTodo) =&gt; [...state, newTodo] // How to add optimistic todo
  );
  
  const addTodo = async (text) =&gt; { // Function to add new todo
    addOptimisticTodo({ id: Date.now(), text, pending: true }); // Show optimistic todo immediately
    await saveTodoToServer(text); // Save to server in background
  };
  
  return ( // Return JSX
    &lt;div&gt;
      {optimisticTodos.map(todo =&gt; ( // Map over optimistic todos (includes pending ones)
        &lt;div key={todo.id} style={{ opacity: todo.pending ? 0.5 : 1 }}&gt; {/* Dim pending todos */}
          {todo.text} {/* Show todo text */}
        &lt;/div&gt;
      ))}
      &lt;button onClick={() =&gt; addTodo('New Task')}&gt; {/* Button adds new todo */}
        Add Todo
      &lt;/button&gt;
    &lt;/div&gt;
  );
}</code></pre>
</div>
</div>2e:T429,<h3>&nbsp;</h3>
<p>Keep UI responsive during expensive updates!</p>
<pre class="language-javascript"><code>function SearchResults() {
  const [query, setQuery] = useState(''); // State for search input
  const [isPending, startTransition] = useTransition(); // Track if expensive update is running
  const deferredQuery = useDeferredValue(query); // Delayed version of query for expensive operations
  
  const handleSearch = (newQuery) =&gt; { // Function to handle search input
    setQuery(newQuery); // Update input immediately for responsiveness
    startTransition(() =&gt; { // Mark expensive operation as low priority
      performExpensiveSearch(deferredQuery); // Run expensive search with delayed query
    });
  };
  
  return ( // Return JSX
    &lt;div&gt;
      &lt;input onChange={(e) =&gt; handleSearch(e.target.value)} /&gt; {/* Input calls handleSearch on change */}
      {isPending &amp;&amp; &lt;div&gt;Searching... üîç&lt;/div&gt;} {/* Show loading only when transition is pending */}
    &lt;/div&gt;
  );
}</code></pre>2f:T62f,<p>Building bigger components from smaller ones - like LEGO blocks!</p>
<div>
<div>
<div>&nbsp;</div>
</div>
<div>
<pre class="language-javascript"><code>// Small, reusable components
function Button({ children, onClick, type = "button" }) {
  return (
    &lt;button type={type} onClick={onClick} className="btn"&gt;
      {children} {/* Content comes from parent */}
    &lt;/button&gt;
  );
}

function Input({ label, ...props }) {
  return (
    &lt;div className="input-group"&gt;
      &lt;label&gt;{label}&lt;/label&gt;
      &lt;input {...props} /&gt; {/* Spread all props to input */}
    &lt;/div&gt;
  );
}

// Composed bigger component
function LoginCard({ onLogin }) {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  
  const handleSubmit = (e) =&gt; {
    e.preventDefault();
    onLogin({ email, password });
  };
  
  return (
    &lt;div className="card"&gt;
      &lt;h2&gt;Login&lt;/h2&gt;
      &lt;form onSubmit={handleSubmit}&gt;
        {/* Composing with reusable components */}
        &lt;Input
          label="Email"
          type="email"
          value={email}
          onChange={(e) =&gt; setEmail(e.target.value)}
        /&gt;
        &lt;Input
          label="Password"
          type="password"
          value={password}
          onChange={(e) =&gt; setPassword(e.target.value)}
        /&gt;
        &lt;Button type="submit"&gt;
          Login
        &lt;/Button&gt;
      &lt;/form&gt;
    &lt;/div&gt;
  );
}</code></pre>
</div>
</div>30:T55c,<p>React follows a <strong>unidirectional data flow</strong> - data flows DOWN from parent to child components, like water flowing downhill!</p>
<h3>Why One-Way Flow?</h3>
<ul>
<li><strong>Predictable</strong>: You always know where data comes from</li>
<li><strong>Debuggable</strong>: Easy to trace data changes</li>
<li><strong>Maintainable</strong>: Changes don't create chaos</li>
</ul>
<pre class="language-javascript"><code>// ‚úÖ Data flows DOWN from App to UserCard
function App() {
  const userName = "Sarah Johnson"; // Data starts here
  const userAge = 25;

  return (
    &lt;div&gt;
      {/* Data flows DOWN to UserCard */}
      &lt;UserCard name={userName} age={userAge} /&gt;
    &lt;/div&gt;
  );
}

function UserCard({ name, age }) {
  return (
    &lt;div&gt;
      {/* UserCard receives and displays the data */}
      &lt;h2&gt;{name}&lt;/h2&gt; {/* Displays: Sarah Johnson */}
      &lt;p&gt;Age: {age}&lt;/p&gt; {/* Displays: Age: 25 */}
    &lt;/div&gt;
  );
}</code></pre>
<h3>üö´ What NOT to do:</h3>
<div>
<pre class="language-javascript"><code>// ‚ùå Child trying to directly modify parent data - Won't work!
function UserCard({ name, age }) {
  // This won't change the parent's data
  name = "Different Name"; // ‚ùå Props are read-only!
  
  return &lt;h2&gt;{name}&lt;/h2&gt;;
}</code></pre>
</div>31:T9ed,<p>Props are like <strong>packages</strong> you send from parent to child components. They carry data, functions, or even other components!</p>
<h3>Basic Props Usage</h3>
<pre class="language-javascript"><code>function WelcomeMessage({ username, isLoggedIn }) {
  return (
    &lt;div&gt;
      {/* Using the username prop */}
      &lt;h1&gt;Hello, {username}!&lt;/h1&gt; 
      {/* Using the isLoggedIn prop for conditional content */}
      &lt;p&gt;{isLoggedIn ? "Welcome back!" : "Please log in"}&lt;/p&gt;
    &lt;/div&gt;
  );
}

// Parent component sending props
function App() {
  return (
    &lt;div&gt;
      {/* Sending username and isLoggedIn as props */}
      &lt;WelcomeMessage 
        username="Alex" 
        isLoggedIn={true} 
      /&gt;
    &lt;/div&gt;
  );
}</code></pre>
<h3>Different Types of Props</h3>
<pre class="language-javascript"><code>function ProductCard({ 
  title,           // String prop
  price,           // Number prop
  isOnSale,        // Boolean prop
  tags,            // Array prop
  product,         // Object prop
  onAddToCart      // Function prop
}) {
  return (
    &lt;div className="product-card"&gt;
      {/* Using string prop */}
      &lt;h3&gt;{title}&lt;/h3&gt;
      
      {/* Using number prop with conditional styling */}
      &lt;p className={isOnSale ? "sale-price" : "regular-price"}&gt;
        ${price}
      &lt;/p&gt;
      
      {/* Using array prop - mapping over tags */}
      &lt;div className="tags"&gt;
        {tags.map((tag, index) =&gt; (
          &lt;span key={index} className="tag"&gt;{tag}&lt;/span&gt;
        ))}
      &lt;/div&gt;
      
      {/* Using object prop */}
      &lt;p&gt;Category: {product.category}&lt;/p&gt;
      &lt;p&gt;Brand: {product.brand}&lt;/p&gt;
      
      {/* Using function prop - calling parent function */}
      &lt;button onClick={() =&gt; onAddToCart(product.id)}&gt;
        Add to Cart
      &lt;/button&gt;
    &lt;/div&gt;
  );
}

// Parent component providing all these props
function Shop() {
  const handleAddToCart = (productId) =&gt; {
    console.log(`Added product ${productId} to cart!`);
  };

  return (
    &lt;ProductCard
      title="Wireless Headphones"
      price={99.99}
      isOnSale={true}
      tags={["electronics", "audio", "wireless"]}
      product={{
        id: 1,
        category: "Electronics",
        brand: "TechBrand"
      }}
      onAddToCart={handleAddToCart}
    /&gt;
  );
}</code></pre>32:T95a,<h2>State vs Props</h2>
<p>Understanding the difference between state and props is crucial for knowing where your data should live!</p>
<h3>Props: Data Coming IN</h3>
<ul>
<li><strong>Read-only</strong>: You can't change props inside a component</li>
<li><strong>From parent</strong>: Always received from a parent component</li>
<li><strong>External data</strong>: Data that comes from outside the component</li>
</ul>
<h3>State: Data Living INSIDE</h3>
<ul>
<li><strong>Changeable</strong>: You can update state inside the component</li>
<li><strong>Internal</strong>: Belongs to the component itself</li>
<li><strong>Component's memory</strong>: What the component "remembers"</li>
</ul>
<pre class="language-javascript"><code>function Counter({ initialCount, title }) {
  // Props (coming from parent):
  // - initialCount: starting number
  // - title: display title
  
  // State (living inside this component):
  const [count, setCount] = useState(initialCount); // Internal counter
  const [isEven, setIsEven] = useState(initialCount % 2 === 0); // Calculated state
  
  const handleIncrement = () =&gt; {
    const newCount = count + 1; // Calculate new value
    setCount(newCount); // Update counter state
    setIsEven(newCount % 2 === 0); // Update even/odd state
  };
  
  return (
    &lt;div&gt;
      {/* Using prop - never changes unless parent changes it */}
      &lt;h2&gt;{title}&lt;/h2&gt;
      
      {/* Using state - changes when we click the button */}
      &lt;p&gt;Count: {count}&lt;/p&gt;
      &lt;p&gt;This number is {isEven ? "even" : "odd"}&lt;/p&gt;
      
      {/* Button updates internal state */}
      &lt;button onClick={handleIncrement}&gt;
        Increment
      &lt;/button&gt;
    &lt;/div&gt;
  );
}

// Parent provides props, but doesn't control internal state
function App() {
  return (
    &lt;div&gt;
      {/* Each counter has its own independent state */}
      &lt;Counter initialCount={0} title="First Counter" /&gt;
      &lt;Counter initialCount={10} title="Second Counter" /&gt;
    &lt;/div&gt;
  );
}</code></pre>
<h3>ü§î Quick Decision Guide:</h3>
<ul>
<li><strong>Use Props when</strong>: Data comes from parent, configuration values, callbacks</li>
<li><strong>Use State when</strong>: Data changes over time, user interactions, component's internal memory</li>
</ul>33:T1265,<p>While data flows DOWN through props, <strong>events flow UP</strong> from child to parent through callback functions!</p>
<h3>Basic Event Flow</h3>
<div>
<div>
<div>&nbsp;</div>
</div>
<div>
<pre class="language-javascript"><code>function LoginForm({ onLogin }) {
  const [username, setUsername] = useState(""); // Internal form state
  const [password, setPassword] = useState(""); // Internal form state
  
  const handleSubmit = (e) =&gt; {
    e.preventDefault(); // Prevent page refresh
    
    // Send data UP to parent through callback
    onLogin({
      username: username,
      password: password
    });
    
    // Clear form after submission
    setUsername("");
    setPassword("");
  };
  
  return (
    &lt;form onSubmit={handleSubmit}&gt;
      &lt;div&gt;
        &lt;input
          type="text"
          placeholder="Username"
          value={username}
          onChange={(e) =&gt; setUsername(e.target.value)} // Update local state
        /&gt;
      &lt;/div&gt;
      &lt;div&gt;
        &lt;input
          type="password"
          placeholder="Password"
          value={password}
          onChange={(e) =&gt; setPassword(e.target.value)} // Update local state
        /&gt;
      &lt;/div&gt;
      &lt;button type="submit"&gt;Login&lt;/button&gt;
    &lt;/form&gt;
  );
}

// Parent component receives data from child
function App() {
  const [user, setUser] = useState(null); // Parent's state
  
  // Callback function that child will call
  const handleUserLogin = (loginData) =&gt; {
    console.log("User trying to login:", loginData);
    
    // Here you'd typically validate credentials
    // For demo, we'll just set the user
    setUser({
      username: loginData.username,
      isLoggedIn: true
    });
  };
  
  return (
    &lt;div&gt;
      {user ? (
        // Show welcome message if logged in
        &lt;div&gt;
          &lt;h1&gt;Welcome, {user.username}!&lt;/h1&gt;
          &lt;button onClick={() =&gt; setUser(null)}&gt;Logout&lt;/button&gt;
        &lt;/div&gt;
      ) : (
        // Show login form if not logged in
        &lt;LoginForm onLogin={handleUserLogin} /&gt;
      )}
    &lt;/div&gt;
  );
}
</code></pre>
</div>
</div>
<h3>Multiple Event Types</h3>
<pre class="language-javascript"><code>function ProductList({ onProductSelect, onProductDelete, onProductEdit }) {
  const products = [
    { id: 1, name: "Laptop", price: 999 },
    { id: 2, name: "Mouse", price: 29 },
    { id: 3, name: "Keyboard", price: 79 }
  ];
  
  return (
    &lt;div&gt;
      {products.map(product =&gt; (
        &lt;div key={product.id} className="product-item"&gt;
          &lt;h3&gt;{product.name}&lt;/h3&gt;
          &lt;p&gt;${product.price}&lt;/p&gt;
          
          {/* Different events flowing up to parent */}
          &lt;button onClick={() =&gt; onProductSelect(product)}&gt;
            View Details
          &lt;/button&gt;
          &lt;button onClick={() =&gt; onProductEdit(product.id)}&gt;
            Edit
          &lt;/button&gt;
          &lt;button onClick={() =&gt; onProductDelete(product.id)}&gt;
            Delete
          &lt;/button&gt;
        &lt;/div&gt;
      ))}
    &lt;/div&gt;
  );
}

// Parent handles all the different events
function Shop() {
  const handleProductSelect = (product) =&gt; {
    console.log("Selected product:", product);
    // Maybe navigate to product details page
  };
  
  const handleProductEdit = (productId) =&gt; {
    console.log("Edit product:", productId);
    // Maybe open edit modal
  };
  
  const handleProductDelete = (productId) =&gt; {
    console.log("Delete product:", productId);
    // Maybe show confirmation dialog
  };
  
  return (
    &lt;ProductList
      onProductSelect={handleProductSelect}
      onProductEdit={handleProductEdit}
      onProductDelete={handleProductDelete}
    /&gt;
  );
}</code></pre>
<h2>üéØ Key Takeaways</h2>
<ol>
<li><strong>Data flows DOWN</strong> (parent &rarr; child) through props</li>
<li><strong>Events flow UP</strong> (child &rarr; parent) through callback functions</li>
<li><strong>Props are read-only</strong> - never modify them directly</li>
<li><strong>State belongs to components</strong> - it's their internal memory</li>
<li><strong>Use props for external data</strong>, <strong>use state for internal data</strong></li>
<li><strong>Event handlers</strong> are your way to send information back up the component tree</li>
</ol>
<p>This foundation makes React predictable and maintainable - once you understand this flow, everything else starts to make sense!</p>34:T587,<p><strong>What it is</strong>: Showing different UI elements based on your data or state - like having different paths your app can take!</p>
<p><strong>Why you need it</strong>: Your app needs to respond to different situations - loading states, user permissions, empty data, errors, etc.</p>
<p><strong>Common patterns</strong>:</p>
<ul>
<li><code>if/else</code> statements for completely different layouts</li>
<li><code>&amp;&amp;</code> operator for show/hide single elements</li>
<li>Ternary <code>? :</code> for two options</li>
<li>Early returns to handle edge cases first</li>
</ul>
<pre class="language-javascript"><code>function UserProfile({ user, isLoading }) {
  // Show loading while data loads
  if (isLoading) {
    return &lt;div&gt;Loading...&lt;/div&gt;; // Early return for loading state
  }
  
  // Show login prompt if no user
  if (!user) {
    return &lt;div&gt;Please log in&lt;/div&gt;; // Early return for no user
  }
  
  // Show profile when user exists
  return (
    &lt;div&gt;
      &lt;h1&gt;Welcome, {user.name}!&lt;/h1&gt;
      {/* Conditional content based on user role */}
      {user.isAdmin &amp;&amp; &lt;button&gt;Admin Panel&lt;/button&gt;}
      {user.isPremium ? (
        &lt;div&gt;‚≠ê Premium Features Available&lt;/div&gt;
      ) : (
        &lt;div&gt;Upgrade to Premium&lt;/div&gt;
      )}
    &lt;/div&gt;
  );
}</code></pre>35:T614,<p>Transform arrays into components - React's bread and butter!</p>
<p><strong>Why keys matter</strong>: React uses keys to track which items changed, were added, or removed. Without proper keys, React might re-render everything or lose component state.</p>
<p><strong>Key rules</strong>:</p>
<ul>
<li>Keys must be unique among siblings</li>
<li>Use stable IDs (not array indexes if list can change)</li>
<li>Keys help React optimize performance</li>
</ul>
<div>
<div>
<div>&nbsp;</div>
</div>
<div>
<pre class="language-javascript"><code>function TodoList({ todos, onToggle }) {
  return (
    &lt;ul&gt;
      {todos.map(todo =&gt; (
        &lt;li key={todo.id}&gt; {/* Key helps React track items */}
          &lt;input
            type="checkbox"
            checked={todo.completed}
            onChange={() =&gt; onToggle(todo.id)} // Send event up to parent
          /&gt;
          &lt;span className={todo.completed ? 'completed' : ''}&gt;
            {todo.text}
          &lt;/span&gt;
        &lt;/li&gt;
      ))}
    &lt;/ul&gt;
  );
}

// Parent component with data
function App() {
  const [todos, setTodos] = useState([
    { id: 1, text: "Learn React", completed: false },
    { id: 2, text: "Build an app", completed: true }
  ]);
  
  const handleToggle = (id) =&gt; {
    setTodos(todos.map(todo =&gt; 
      todo.id === id ? { ...todo, completed: !todo.completed } : todo
    ));
  };
  
  return &lt;TodoList todos={todos} onToggle={handleToggle} /&gt;;
}</code></pre>
</div>
</div>36:T73e,<p><strong>What it is</strong>: Forms where React state controls the input values instead of the DOM - React becomes the "single source of truth"</p>
<p><strong>Why use controlled forms</strong>:</p>
<ul>
<li>You can validate input as user types</li>
<li>Easy to reset/clear forms programmatically</li>
<li>Data flows consistently with React patterns</li>
<li>You can format/transform input values</li>
</ul>
<p><strong>The pattern</strong>: Input value comes from state &rarr; User types &rarr; onChange updates state &rarr; Input shows new state value</p>
<div>
<pre class="language-javascript"><code>function ContactForm({ onSubmit }) {
  const [formData, setFormData] = useState({
    name: '',
    email: '',
    message: ''
  });
  
  // Handle any input change
  const handleChange = (e) =&gt; {
    setFormData({
      ...formData, // Keep existing data
      [e.target.name]: e.target.value // Update changed field
    });
  };
  
  const handleSubmit = (e) =&gt; {
    e.preventDefault(); // Prevent page reload
    onSubmit(formData); // Send data to parent
    setFormData({ name: '', email: '', message: '' }); // Reset form
  };
  
  return (
    &lt;form onSubmit={handleSubmit}&gt;
      &lt;input
        name="name"
        value={formData.name} // React controls the value
        onChange={handleChange} // Update state on change
        placeholder="Your Name"
      /&gt;
      &lt;input
        name="email"
        value={formData.email}
        onChange={handleChange}
        placeholder="Your Email"
      /&gt;
      &lt;textarea
        name="message"
        value={formData.message}
        onChange={handleChange}
        placeholder="Your Message"
      /&gt;
      &lt;button type="submit"&gt;Send Message&lt;/button&gt;
    &lt;/form&gt;
  );
}</code></pre>
</div>37:T9d4,<p><strong>What it is</strong>: A pattern where a component receives a function as a prop that returns JSX - basically sharing component logic without inheritance!</p>
<p><strong>Why it's powerful</strong>:</p>
<ul>
<li><strong>Logic reuse</strong>: Share stateful logic between components</li>
<li><strong>Flexibility</strong>: The parent decides what to render</li>
<li><strong>Separation</strong>: Logic component vs presentation component</li>
<li><strong>No nesting</strong>: Cleaner than higher-order components</li>
</ul>
<p><strong>When to use</strong>: When multiple components need the same logic but different UI</p>
<pre class="language-javascript"><code>// Render prop component - handles mouse tracking logic
function MouseTracker({ render }) {
  // State to track mouse position coordinates
  const [mousePosition, setMousePosition] = useState({ x: 0, y: 0 });
  
  useEffect(() =&gt; {
    // Function to update state when mouse moves
    const handleMouseMove = (e) =&gt; {
      setMousePosition({ x: e.clientX, y: e.clientY }); // Get mouse coordinates from event
    };
    
    // Add event listener to track mouse movement
    document.addEventListener('mousemove', handleMouseMove);
    // Cleanup function to remove listener when component unmounts
    return () =&gt; document.removeEventListener('mousemove', handleMouseMove);
  }, []); // Empty dependency array - run once on mount
  
  // Call the render prop function with current mouse position
  return render(mousePosition);
}

// Different ways to use the same logic
function App() {
  return (
    &lt;div&gt;
      {/* First usage - display coordinates as text */}
      &lt;MouseTracker 
        render={({ x, y }) =&gt; ( // Destructure coordinates from render prop
          &lt;h1&gt;Mouse is at ({x}, {y})&lt;/h1&gt; // Show coordinates in heading
        )}
      /&gt;
      
      {/* Second usage - show red dot following mouse */}
      &lt;MouseTracker 
        render={({ x, y }) =&gt; ( // Same data, different UI
          &lt;div style={{ 
            position: 'absolute', // Position absolutely on page
            left: x, // Use x coordinate for horizontal position
            top: y, // Use y coordinate for vertical position
            width: 10, // Make it a small square
            height: 10,
            backgroundColor: 'red' // Make it red and visible
          }} /&gt;
        )}
      /&gt;
    &lt;/div&gt;
  );
}</code></pre>
<p>&nbsp;</p>38:T813,<p>Moving state to a common parent when multiple components need it!</p>
<pre class="language-javascript"><code>// Two components that need to share data
function SearchBox({ query, onQueryChange }) {
  return (
    &lt;input
      value={query}
      onChange={(e) =&gt; onQueryChange(e.target.value)} // Send data up
      placeholder="Search products..."
    /&gt;
  );
}

function ProductList({ products, query }) {
  // Filter products based on search query
  const filteredProducts = products.filter(product =&gt;
    product.name.toLowerCase().includes(query.toLowerCase())
  );
  
  return (
    &lt;div&gt;
      {filteredProducts.map(product =&gt; (
        &lt;div key={product.id}&gt;
          &lt;h3&gt;{product.name}&lt;/h3&gt;
          &lt;p&gt;${product.price}&lt;/p&gt;
        &lt;/div&gt;
      ))}
    &lt;/div&gt;
  );
}

// Parent holds shared state
function Shop() {
  const [searchQuery, setSearchQuery] = useState(''); // Lifted state
  const [products] = useState([
    { id: 1, name: "Laptop", price: 999 },
    { id: 2, name: "Mouse", price: 29 }
  ]);
  
  return (
    &lt;div&gt;
      {/* Both components get data from parent */}
      &lt;SearchBox 
        query={searchQuery} 
        onQueryChange={setSearchQuery} 
      /&gt;
      &lt;ProductList 
        products={products} 
        query={searchQuery} 
      /&gt;
    &lt;/div&gt;
  );
}</code></pre>
<h2>üéØ Common Use Key Points</h2>
<ol>
<li><strong>Conditional rendering</strong>: Use <code>if/else</code>, <code>&amp;&amp;</code>, and <code>?:</code> for different content</li>
<li><strong>List rendering</strong>: Always use <code>key</code> prop for efficient updates</li>
<li><strong>Controlled forms</strong>: React state controls input values</li>
<li><strong>Component composition</strong>: Build complex UIs from simple parts</li>
<li><strong>Lift state up</strong>: Move shared state to the nearest common parent</li>
</ol>
<p>These patterns handle 90% of your daily React data flow needs! üéØ</p>39:Tbc8,<p><strong>What it is</strong>: A function that takes a component and returns a new enhanced component - like wrapping gifts with extra features!</p>
<p><strong>Why use HOCs</strong>:</p>
<ul>
<li><strong>Code reuse</strong>: Add same functionality to multiple components</li>
<li><strong>Cross-cutting concerns</strong>: Authentication, logging, error handling</li>
<li><strong>Props manipulation</strong>: Transform or add props before passing down</li>
</ul>
<p><strong>Pattern</strong>: <code>const EnhancedComponent = higherOrderComponent(OriginalComponent)</code></p>
<pre class="language-javascript"><code>// HOC that adds loading functionality
function withLoading(WrappedComponent) {
  // Return a new component that wraps the original
  return function LoadingComponent({ isLoading, ...props }) {
    // Check if currently loading
    if (isLoading) {
      return &lt;div&gt;Loading...&lt;/div&gt;; // Show loading spinner instead of component
    }
    
    // If not loading, render the original component with all props
    return &lt;WrappedComponent {...props} /&gt;;
  };
}

// HOC that adds error handling
function withErrorHandling(WrappedComponent) {
  // Return enhanced component with error handling
  return function ErrorHandlingComponent(props) {
    // State to track if component has errored
    const [hasError, setHasError] = useState(false);
    
    // If error occurred, show error message
    if (hasError) {
      return &lt;div&gt;Something went wrong!&lt;/div&gt;;
    }
    
    // Try to render component, catch any errors
    try {
      return &lt;WrappedComponent {...props} onError={() =&gt; setHasError(true)} /&gt;;
    } catch (error) {
      setHasError(true); // Set error state if component crashes
      return &lt;div&gt;Something went wrong!&lt;/div&gt;; // Show error UI
    }
  };
}

// Original simple components
function UserProfile({ user }) {
  return &lt;div&gt;Welcome, {user.name}!&lt;/div&gt;; // Just display user name
}

function ProductList({ products }) {
  return (
    &lt;div&gt;
      {/* Map over products array to display each one */}
      {products.map(p =&gt; &lt;div key={p.id}&gt;{p.name}&lt;/div&gt;)}
    &lt;/div&gt;
  );
}

// Enhanced components using HOCs
const UserProfileWithLoading = withLoading(UserProfile); // Add loading to UserProfile
const ProductListWithLoadingAndErrors = withErrorHandling(withLoading(ProductList)); // Chain multiple HOCs

// Usage in parent component
function App() {
  const [user, setUser] = useState(null); // User data state
  const [isLoading, setIsLoading] = useState(true); // Loading state
  
  return (
    &lt;div&gt;
      {/* Enhanced component gets loading prop */}
      &lt;UserProfileWithLoading user={user} isLoading={isLoading} /&gt;
      {/* Component with both loading and error handling */}
      &lt;ProductListWithLoadingAndErrors products={[]} isLoading={false} /&gt;
    &lt;/div&gt;
  );
}</code></pre>3a:T1414,<p><strong>What it is</strong>: Complex form validation with real-time feedback, multiple validation rules, and error management.</p>
<p><strong>Key concepts</strong>:</p>
<ul>
<li><strong>Field-level validation</strong>: Validate as user types</li>
<li><strong>Form-level validation</strong>: Check relationships between fields</li>
<li><strong>Async validation</strong>: Server-side validation (email exists, etc.)</li>
<li><strong>Error state management</strong>: Track errors per field</li>
</ul>
<div>
<pre class="language-javascript"><code>function AdvancedForm({ onSubmit }) {
  // State to hold all form field values
  const [formData, setFormData] = useState({
    email: '',
    password: '',
    confirmPassword: ''
  });
  
  // State to track validation errors for each field
  const [errors, setErrors] = useState({});
  // State to track which fields user has interacted with
  const [touched, setTouched] = useState({});
  
  // Function to validate individual fields based on rules
  const validateField = (name, value) =&gt; {
    switch (name) {
      case 'email':
        // Check if email format is valid using regex
        return /\S+@\S+\.\S+/.test(value) ? '' : 'Invalid email';
      case 'password':
        // Check if password is at least 8 characters
        return value.length &gt;= 8 ? '' : 'Password must be 8+ characters';
      case 'confirmPassword':
        // Check if confirmation matches original password
        return value === formData.password ? '' : 'Passwords must match';
      default:
        return ''; // No error for unknown fields
    }
  };
  
  // Handle input changes as user types
  const handleChange = (e) =&gt; {
    const { name, value } = e.target; // Get field name and new value
    
    // Update form data with new value
    setFormData(prev =&gt; ({ ...prev, [name]: value }));
    
    // Only validate if user has already touched this field
    if (touched[name]) {
      setErrors(prev =&gt; ({
        ...prev,
        [name]: validateField(name, value) // Update error for this field
      }));
    }
  };
  
  // Handle when user leaves a field (blur event)
  const handleBlur = (e) =&gt; {
    const { name, value } = e.target; // Get field that was blurred
    
    // Mark this field as touched so we show errors
    setTouched(prev =&gt; ({ ...prev, [name]: true }));
    
    // Validate the field now that it's been touched
    setErrors(prev =&gt; ({
      ...prev,
      [name]: validateField(name, value)
    }));
  };
  
  // Handle form submission
  const handleSubmit = (e) =&gt; {
    e.preventDefault(); // Prevent page reload
    
    // Validate all fields before submitting
    const newErrors = {};
    Object.keys(formData).forEach(key =&gt; {
      newErrors[key] = validateField(key, formData[key]); // Check each field
    });
    
    setErrors(newErrors); // Update error state
    // Mark all fields as touched to show any errors
    setTouched({ email: true, password: true, confirmPassword: true });
    
    // Only submit if there are no validation errors
    const hasErrors = Object.values(newErrors).some(error =&gt; error !== '');
    if (!hasErrors) {
      onSubmit(formData); // Call parent's submit handler
    }
  };
  
  return (
    &lt;form onSubmit={handleSubmit}&gt;
      &lt;div&gt;
        &lt;input
          name="email" // Field name for identification
          type="email" // HTML5 email input type
          value={formData.email} // Controlled input - value from state
          onChange={handleChange} // Update state when user types
          onBlur={handleBlur} // Validate when user leaves field
          placeholder="Email"
        /&gt;
        {/* Show error only if field was touched and has error */}
        {touched.email &amp;&amp; errors.email &amp;&amp; (
          &lt;span style={{color: 'red'}}&gt;{errors.email}&lt;/span&gt;
        )}
      &lt;/div&gt;
      
      &lt;div&gt;
        &lt;input
          name="password"
          type="password" // Hide password characters
          value={formData.password}
          onChange={handleChange}
          onBlur={handleBlur}
          placeholder="Password"
        /&gt;
        {/* Conditional error display */}
        {touched.password &amp;&amp; errors.password &amp;&amp; (
          &lt;span style={{color: 'red'}}&gt;{errors.password}&lt;/span&gt;
        )}
      &lt;/div&gt;
      
      &lt;div&gt;
        &lt;input
          name="confirmPassword"
          type="password"
          value={formData.confirmPassword}
          onChange={handleChange}
          onBlur={handleBlur}
          placeholder="Confirm Password"
        /&gt;
        {/* Show password mismatch error */}
        {touched.confirmPassword &amp;&amp; errors.confirmPassword &amp;&amp; (
          &lt;span style={{color: 'red'}}&gt;{errors.confirmPassword}&lt;/span&gt;
        )}
      &lt;/div&gt;
      
      &lt;button type="submit"&gt;Register&lt;/button&gt;
    &lt;/form&gt;
  );
}</code></pre>
</div>3b:T92f,<p><strong>What it is</strong>: Strategies for loading data from APIs and managing loading/error states in your components.</p>
<p><strong>Common patterns</strong>:</p>
<ul>
<li><strong>Fetch on mount</strong>: Load data when component appears</li>
<li><strong>Fetch on demand</strong>: Load data when user interacts</li>
<li><strong>Optimistic updates</strong>: Update UI before server confirms</li>
<li><strong>Error boundaries</strong>: Handle fetch failures gracefully</li>
</ul>
<pre class="language-javascript"><code>Custom hook for data fetching
function useApi(url) {
  const [data, setData] = useState(null); // Store fetched data
  const [loading, setLoading] = useState(true); // Track loading state
  const [error, setError] = useState(null); // Store any error messages
  
  useEffect(() =&gt; {
    // Async function to fetch data from API
    const fetchData = async () =&gt; {
      try {
        setLoading(true); // Set loading to true when starting fetch
        const response = await fetch(url); // Make API request
        if (!response.ok) throw new Error('Failed to fetch'); // Check if request succeeded
        const result = await response.json(); // Parse JSON response
        setData(result); // Store the fetched data
      } catch (err) {
        setError(err.message); // Store error message if fetch fails
      } finally {
        setLoading(false); // Always set loading to false when done
      }
    };
    
    fetchData(); // Call the fetch function
  }, [url]); // Re-run effect if URL changes
  
  // Return all the state values for components to use
  return { data, loading, error };
}

// Component using the data fetching pattern
function UserList() {
  // Use our custom hook to fetch users data
  const { data: users, loading, error } = useApi('/api/users');
  
  // Show loading state while fetching
  if (loading) return &lt;div&gt;Loading users...&lt;/div&gt;;
  // Show error if fetch failed
  if (error) return &lt;div&gt;Error: {error}&lt;/div&gt;;
  
  // Show the actual data once loaded
  return (
    &lt;div&gt;
      {/* Safely map over users (using optional chaining) */}
      {users?.map(user =&gt; (
        &lt;div key={user.id}&gt;{user.name}&lt;/div&gt; // Display each user's name
      ))}
    &lt;/div&gt;
  );
}</code></pre>3c:Tb5e,<div>
<p><strong>What it is</strong>: React 19's new way to handle data mutations that run on the server - no more manual API calls for forms!</p>
<p><strong>Why it's revolutionary</strong>:</p>
<ul>
<li><strong>Automatic loading states</strong>: React handles pending states</li>
<li><strong>Error handling</strong>: Built-in error boundaries</li>
<li><strong>Progressive enhancement</strong>: Works without JavaScript</li>
<li><strong>Optimistic updates</strong>: Update UI immediately, rollback if needed</li>
</ul>
<div>
<div>
<div>&nbsp;</div>
</div>
<div>
<pre class="language-javascript"><code>// Server Action (runs on server)
async function createUser(formData) {
  'use server'; // This directive tells React this function runs on the server
  
  // Extract form data using FormData API
  const name = formData.get('name'); // Get name field value
  const email = formData.get('email'); // Get email field value
  
  // Server-side validation
  if (!name || !email) {
    throw new Error('Name and email required'); // Throw error if validation fails
  }
  
  // Save to database (this runs on server)
  const user = await db.users.create({ name, email }); // Create new user record
  return user; // Return created user data
}

// Component using Server Action
function UserForm() {
  // Hook to track pending state during server action
  const [pending, setPending] = useTransition();
  
  return (
    // Form automatically calls server action on submit
    &lt;form action={createUser}&gt;
      &lt;input 
        name="name" // Name attribute matches formData.get('name')
        placeholder="Name" 
        required // HTML5 validation
      /&gt;
      &lt;input 
        name="email" // Name attribute matches formData.get('email')
        type="email" // HTML5 email validation
        placeholder="Email" 
        required 
      /&gt;
      
      &lt;button 
        type="submit" 
        disabled={pending} // Disable button while action is running
      &gt;
        {/* Show different text based on pending state */}
        {pending ? 'Creating...' : 'Create User'}
      &lt;/button&gt;
    &lt;/form&gt;
  );
}
</code></pre>
</div>
</div>
<hr>
<h2>üéØ Advanced Key Points</h2>
<ol>
<li><strong>Render Props</strong>: Share logic by passing functions that return JSX</li>
<li><strong>HOCs</strong>: Wrap components to add functionality - great for cross-cutting concerns</li>
<li><strong>Advanced validation</strong>: Real-time validation with proper error state management</li>
<li><strong>Data fetching</strong>: Custom hooks for API calls with loading/error states</li>
<li><strong>Server Actions</strong>: React 19's game-changer for form submissions and mutations</li>
</ol>
<p>These patterns solve complex data flow challenges and make your React apps more robust! üöÄ</p>
</div>
<div>&nbsp;</div>3d:T570,<p><em>Build layouts that wrap around different pages - like a picture frame!</em></p>
<div>
<pre class="language-javascript"><code>Build layouts that wrap around different pages - like a picture frame!
import { Outlet } from 'react-router-dom';

// Layout component - the "picture frame"
function Layout() {
  return (
    &lt;div&gt;
      &lt;header&gt;My App Header&lt;/header&gt;      {/* Shows on all pages */}
      &lt;nav&gt;Navigation here&lt;/nav&gt;          {/* Shows on all pages */}
      
      &lt;main&gt;
        &lt;Outlet /&gt;                        {/* Child routes appear HERE! */}
      &lt;/main&gt;
      
      &lt;footer&gt;Footer content&lt;/footer&gt;     {/* Shows on all pages */}
    &lt;/div&gt;
  );
}

// Router setup with nested routes
const router = createBrowserRouter([
  {
    path: "/",
    element: &lt;Layout /&gt;,          // Parent route with layout
    children: [                   // Child routes that go inside &lt;Outlet /&gt;
      {
        index: true,              // Shows at "/" (same as path: "")
        element: &lt;Home /&gt;
      },
      {
        path: "products",         // Shows at "/products"
        element: &lt;Products /&gt;
      },
      {
        path: "contact",          // Shows at "/contact"
        element: &lt;Contact /&gt;
      }
    ]
  }
]);</code></pre>
</div>3e:T466,<p><em>Keep your secret pages... actually secret!</em></p>
<p>Protected routes work by creating a wrapper component that checks authentication status before rendering the actual page content. If the user isn't authenticated, they get redirected to a login page instead of seeing the protected content.</p>
<div>
<div>
<div>&nbsp;</div>
</div>
<div>
<pre class="language-javascript"><code>// Create a wrapper component for protected routes
function ProtectedRoute({ children }) {
  const user = useAuth(); // Your auth hook
  const navigate = useNavigate(); // For redirecting
  
  // If no user, redirect to login
  if (!user) {
    navigate('/login');
    return null; // Don't render anything while redirecting
  }
  
  // User is authenticated, show the protected content
  return children;
}

// Usage in your routes
&lt;Route 
  path="/dashboard" 
  element={
    &lt;ProtectedRoute&gt;
      &lt;Dashboard /&gt;
    &lt;/ProtectedRoute&gt;
  } 
/&gt;</code></pre>
</div>
</div>
<p><strong>Pro Tip</strong>: You can also check for specific permissions or roles in your ProtectedRoute!</p>3f:T578,<p><em>Declare your routes like a boss with configuration objects</em></p>
<p>The useRoutes hook lets you define your entire routing structure as a JavaScript object instead of JSX components. This approach makes it easier to programmatically generate routes, apply middleware, and manage complex nested route hierarchies.</p>
<div>
<div>
<div>&nbsp;</div>
</div>
<div>
<pre class="language-javascript"><code>import { useRoutes } from 'react-router-dom';

function App() {
  // Define all routes in a clean config object
  const routes = useRoutes([
    {
      path: '/', // Root path
      element: &lt;Layout /&gt;, // Wrapper component
      children: [ // Nested routes
        { index: true, element: &lt;Home /&gt; }, // Default child route
        { path: 'about', element: &lt;About /&gt; },
        { 
          path: 'products/:id', // Dynamic route
          element: &lt;ProductDetail /&gt;
        }
      ]
    },
    {
      path: '/admin', // Separate route group
      element: &lt;AdminLayout /&gt;,
      children: [
        { path: 'users', element: &lt;UserList /&gt; },
        { path: 'settings', element: &lt;Settings /&gt; }
      ]
    }
  ]);

  // Return the configured routes
  return routes;
}</code></pre>
</div>
</div>
<p><strong>Why use this?</strong> Perfect for complex route structures and programmatic route generation!</p>40:T4f4,<p><em>Load components only when needed - your users will thank you!</em></p>
<p>Code-splitting breaks your app into smaller chunks that load on-demand, reducing initial bundle size. React's lazy() function dynamically imports components, and Suspense provides a fallback UI while the component loads.</p>
<pre class="language-javascript"><code>import { lazy, Suspense } from 'react';

// Lazy load components (they'll be separate bundles)
const Dashboard = lazy(() =&gt; import('./Dashboard'));
const Profile = lazy(() =&gt; import('./Profile'));

function App() {
  return (
    &lt;Routes&gt;
      &lt;Route 
        path="/dashboard" 
        element={
          // Wrap lazy components in Suspense
          &lt;Suspense fallback={&lt;div&gt;Loading dashboard...&lt;/div&gt;}&gt;
            &lt;Dashboard /&gt;
          &lt;/Suspense&gt;
        } 
      /&gt;
      &lt;Route 
        path="/profile" 
        element={
          &lt;Suspense fallback={&lt;div&gt;Loading profile...&lt;/div&gt;}&gt;
            &lt;Profile /&gt;
          &lt;/Suspense&gt;
        } 
      /&gt;
    &lt;/Routes&gt;
  );
}</code></pre>
<p><strong>Bundle Size Win!</strong> Each lazy component becomes a separate chunk that loads on-demand.</p>41:T549,<p><em>Catch route-level errors gracefully</em></p>
<p>Error boundaries with errorElement provide route-specific error handling, catching JavaScript errors anywhere in the route's component tree. Instead of crashing the entire app, only the affected route shows an error UI while the rest of the app continues working.</p>
<div>
<div>
<div>&nbsp;</div>
</div>
<div>
<pre class="language-javascript"><code>// Your error boundary component
function RouteErrorBoundary() {
  const error = useRouteError(); // Get the error details
  
  return (
    &lt;div&gt;
      &lt;h2&gt;Oops! Something went wrong&lt;/h2&gt;
      &lt;p&gt;{error.message}&lt;/p&gt; {/* Show error message */}
      &lt;button onClick={() =&gt; window.location.reload()}&gt;
        Try Again
      &lt;/button&gt;
    &lt;/div&gt;
  );
}

// Use errorElement in your routes
const routes = useRoutes([
  {
    path: '/',
    element: &lt;Layout /&gt;,
    errorElement: &lt;RouteErrorBoundary /&gt;, // Catches errors in this route tree
    children: [
      {
        path: 'dashboard',
        element: &lt;Dashboard /&gt;,
        errorElement: &lt;DashboardError /&gt; // Specific error for this route
      }
    ]
  }
]);</code></pre>
</div>
</div>
<p><strong>Error Isolation</strong>: Errors in one route won't crash your entire app!</p>42:T436,<p><em>Remember scroll positions like a pro</em></p>
<p>Scroll restoration automatically remembers where users were scrolled on each page and restores that position when they navigate back. This creates a more native app-like experience, especially important for long pages or infinite scroll scenarios.</p>
<pre class="language-javascript"><code>import { ScrollRestoration } from 'react-router-dom';

function App() {
  return (
    &lt;div&gt;
      {/* Your routes */}
      &lt;Routes&gt;
        &lt;Route path="/" element={&lt;Home /&gt;} /&gt;
        &lt;Route path="/blog" element={&lt;Blog /&gt;} /&gt;
      &lt;/Routes&gt;
      
      {/* Add this component to restore scroll positions */}
      &lt;ScrollRestoration 
        getKey={(location) =&gt; {
          // Custom key function for scroll restoration
          return location.pathname; // Restore per pathname
        }}
      /&gt;
    &lt;/div&gt;
  );
}</code></pre>
<p><strong>Magic Behavior</strong>: Users navigate back and their scroll position is restored automatically!</p>43:T6ec,<p><em>Load data and handle forms like a full-stack framework</em></p>
<p>Loaders fetch data before a route renders, ensuring your components always have the data they need upfront. Actions handle form submissions and mutations, providing a seamless way to update data and trigger navigation - it's like having a backend framework built into your frontend routing!</p>
<h3>Loaders (Data Fetching)</h3>
<pre class="language-javascript"><code>// Define a loader function
async function productLoader({ params }) {
  const productId = params.id; // Get URL parameter
  const product = await fetch(`/api/products/${productId}`); // Fetch data
  return product.json(); // Return the data
}

// Use loader in route config
{
  path: '/products/:id',
  element: &lt;ProductDetail /&gt;,
  loader: productLoader, // Data loads before component renders
  errorElement: &lt;ProductError /&gt;
}

// Access loaded data in your component
function ProductDetail() {
  const product = useLoaderData(); // Get the loaded data
  
  return (
    &lt;div&gt;
      &lt;h1&gt;{product.name}&lt;/h1&gt; {/* Data is ready to use! */}
      &lt;p&gt;{product.description}&lt;/p&gt;
    &lt;/div&gt;
  );
}</code></pre>
<h2>üéØ Pro Tips for Advanced Routing</h2>
<ol>
<li><strong>Combine Protection + Loading</strong>: Use loaders in protected routes to fetch user-specific data</li>
<li><strong>Error Boundaries Everywhere</strong>: Set errorElement at multiple levels for granular error handling</li>
<li><strong>Smart Code Splitting</strong>: Split by route, not just by component</li>
<li><strong>Prefetch on Hover</strong>: Use <code>&lt;Link prefetch="intent"&gt;</code> to load routes when users hover over links</li>
</ol>
<h3><code>&nbsp;</code></h3>44:T4c6,<p><em>Help React identify which items changed, added, or removed</em></p>
<p>Keys help React's reconciliation algorithm efficiently update lists by identifying which items have changed, been added, or removed. Without proper keys, React has to re-render entire lists instead of just the changed items, leading to poor performance and potential bugs.</p>
<div>
<div>
<div>&nbsp;</div>
</div>
<div>
<pre class="language-javascript"><code>// ‚ùå Bad: Using array index as key
function TodoList({ todos }) {
  return (
    &lt;ul&gt;
      {todos.map((todo, index) =&gt; (
        &lt;li key={index}&gt; {/* Don't use index as key! */}
          {todo.text}
        &lt;/li&gt;
      ))}
    &lt;/ul&gt;
  );
}

// ‚úÖ Good: Using unique, stable identifier
function TodoList({ todos }) {
  return (
    &lt;ul&gt;
      {todos.map((todo) =&gt; (
        &lt;li key={todo.id}&gt; {/* Use unique ID as key */}
          &lt;input type="checkbox" checked={todo.completed} /&gt;
          {todo.text}
        &lt;/li&gt;
      ))}
    &lt;/ul&gt;
  );
}</code></pre>
</div>
</div>
<p><strong>Performance Win</strong>: Proper keys prevent unnecessary re-renders and maintain component state!</p>45:T57c,<p>React.memo() is a higher-order component that wraps your component and only re-renders it when its props actually change. It's like a performance shield that prevents unnecessary renders when parent components update but your component's props stay the same.</p>
<div>
<div>
<div>&nbsp;</div>
</div>
<div>
<pre class="language-javascript"><code>// Component that might re-render unnecessarily
function ExpensiveComponent({ name, count }) {
  console.log('ExpensiveComponent rendered'); // This will log on every render
  
  return (
    &lt;div&gt;
      &lt;h2&gt;{name}&lt;/h2&gt; {/* Display the name prop */}
      &lt;p&gt;Count: {count}&lt;/p&gt; {/* Display the count prop */}
    &lt;/div&gt;
  );
}

// Wrap with React.memo to prevent unnecessary re-renders
const MemoizedComponent = React.memo(ExpensiveComponent);

// Usage in parent component
function App() {
  const [unrelatedState, setUnrelatedState] = useState(0);
  
  return (
    &lt;div&gt;
      &lt;MemoizedComponent name="John" count={5} /&gt; {/* Won't re-render unless props change */}
      &lt;button onClick={() =&gt; setUnrelatedState(prev =&gt; prev + 1)}&gt;
        Update unrelated state: {unrelatedState}
      &lt;/button&gt;
    &lt;/div&gt;
  );
}</code></pre>
<p><strong>Memo Magic</strong>: Component only re-renders when name or count props actually change!</p>
</div>
</div>46:T501,<p><em>Measure and identify performance bottlenecks</em></p>
<p>React Profiler helps you measure how often components render and how long they take, making it easy to spot performance problems. The Profiler component wraps parts of your app and calls a callback function with timing information whenever components render.</p>
<div>
<div>
<div>&nbsp;</div>
</div>
<div>
<pre class="language-javascript"><code>import { Profiler } from 'react';

function App() {
  // Callback function to handle profiling data
  function onRenderCallback(id, phase, actualDuration) {
    console.log('Component:', id); // Which component was profiled
    console.log('Phase:', phase); // 'mount' or 'update'
    console.log('Duration:', actualDuration); // How long it took to render
  }

  return (
    &lt;div&gt;
      {/* Wrap components you want to profile */}
      &lt;Profiler id="Navigation" onRender={onRenderCallback}&gt;
        &lt;Navigation /&gt;
      &lt;/Profiler&gt;
      
      &lt;Profiler id="MainContent" onRender={onRenderCallback}&gt;
        &lt;MainContent /&gt;
      &lt;/Profiler&gt;
    &lt;/div&gt;
  );
}</code></pre>
</div>
</div>
<p><strong>Debug Power</strong>: See exactly which components are slow and how often they render!</p>47:T540,<p><em>Load components only when needed</em></p>
<p>Code splitting with React.lazy() and Suspense allows you to split your bundle into smaller chunks that load on-demand. This reduces initial load time by only loading the code users actually need, when they need it.</p>
<pre class="language-javascript"><code>import { lazy, Suspense } from 'react';

// Lazy load heavy components
const HeavyDashboard = lazy(() =&gt; import('./HeavyDashboard'));
const HeavyChart = lazy(() =&gt; import('./HeavyChart'));

function App() {
  const [showDashboard, setShowDashboard] = useState(false);
  
  return (
    &lt;div&gt;
      &lt;button onClick={() =&gt; setShowDashboard(true)}&gt;
        Load Dashboard {/* Component loads when button is clicked */}
      &lt;/button&gt;
      
      {showDashboard &amp;&amp; (
        &lt;Suspense fallback={&lt;div&gt;Loading dashboard...&lt;/div&gt;}&gt;
          &lt;HeavyDashboard /&gt; {/* Only loads when needed */}
          &lt;Suspense fallback={&lt;div&gt;Loading chart...&lt;/div&gt;}&gt;
            &lt;HeavyChart /&gt; {/* Nested Suspense for granular loading */}
          &lt;/Suspense&gt;
        &lt;/Suspense&gt;
      )}
    &lt;/div&gt;
  );
}</code></pre>
<p><strong>Bundle Split</strong>: Each lazy component becomes a separate chunk that loads on-demand!</p>48:T452,<p><em>Render only visible items in large lists</em></p>
<p>Virtualization renders only the items currently visible in the viewport, dramatically improving performance for large lists. Instead of rendering thousands of DOM nodes, you only render what users can actually see.</p>
<pre class="language-javascript"><code>import { FixedSizeList as List } from 'react-window';

// Individual row component
function Row({ index, style, data }) {
  return (
    &lt;div style={style}&gt; {/* Positioning handled by react-window */}
      &lt;div&gt;Item {data[index].name}&lt;/div&gt; {/* Render individual item */}
    &lt;/div&gt;
  );
}

function VirtualizedList({ items }) {
  return (
    &lt;List
      height={400} // Container height
      itemCount={items.length} // Total number of items
      itemSize={50} // Height of each item
      itemData={items} // Data passed to each row
    &gt;
      {Row} {/* Component to render each row */}
    &lt;/List&gt;
  );
}</code></pre>
<p><strong>Viewport Magic</strong>: Only 8-10 items rendered even with 10,000+ items in the list!</p>49:T5bf,<p><em>Progressive loading for better user experience</em></p>
<p>Streaming with Suspense allows parts of your UI to load progressively, showing content as soon as it's ready instead of waiting for everything. This creates a much smoother loading experience where users see content appearing incrementally.</p>
<div>
<div>
<div>&nbsp;</div>
</div>
<div>
<pre class="language-javascript"><code>import { Suspense, startTransition } from 'react';

function App() {
  const [showContent, setShowContent] = useState(false);
  
  const handleLoadContent = () =&gt; {
    // startTransition marks this update as non-urgent
    startTransition(() =&gt; {
      setShowContent(true); // UI stays responsive during loading
    });
  };

  return (
    &lt;div&gt;
      &lt;header&gt;My App&lt;/header&gt; {/* Shows immediately */}
      &lt;button onClick={handleLoadContent}&gt;Load Content&lt;/button&gt;
      
      {showContent &amp;&amp; (
        &lt;Suspense fallback={&lt;div&gt;Loading posts...&lt;/div&gt;}&gt;
          &lt;PostList /&gt; {/* Streams in when ready */}
          &lt;Suspense fallback={&lt;div&gt;Loading comments...&lt;/div&gt;}&gt;
            &lt;CommentList /&gt; {/* Streams in separately */}
          &lt;/Suspense&gt;
        &lt;/Suspense&gt;
      )}
    &lt;/div&gt;
  );
}</code></pre>
</div>
</div>
<p><strong>Streaming Win</strong>: Content appears progressively instead of all-or-nothing loading!</p>4a:T7f9,<p><em>Keep your UI responsive during heavy operations</em></p>
<p>Concurrent rendering allows React to pause and resume work, keeping the UI responsive even during heavy computations. useTransition and useDeferredValue help you prioritize urgent updates (like user interactions) over less important ones.</p>
<pre class="language-javascript"><code>import { useTransition, useDeferredValue, useState } from 'react';

function SearchApp() {
  const [query, setQuery] = useState('');
  const [isPending, startTransition] = useTransition(); // Track transition state
  const deferredQuery = useDeferredValue(query); // Defer less urgent updates
  
  const handleSearch = (value) =&gt; {
    setQuery(value); // Urgent: update input immediately
    
    startTransition(() =&gt; {
      // Non-urgent: defer expensive search operation
      performExpensiveSearch(deferredQuery);
    });
  };

  return (
    &lt;div&gt;
      &lt;input 
        type="text"
        onChange={(e) =&gt; handleSearch(e.target.value)} // Input stays responsive
        placeholder="Search..."
      /&gt;
      {isPending &amp;&amp; &lt;div&gt;Searching...&lt;/div&gt;} {/* Show loading state */}
      &lt;SearchResults query={deferredQuery} /&gt; {/* Uses deferred value */}
    &lt;/div&gt;
  );
}</code></pre>
<p><strong>Concurrent Magic</strong>: UI stays responsive even during heavy search operations!</p>
<p>&nbsp;</p>
<h2>üéØ Performance Pro Tips</h2>
<ol>
<li><strong>Profile First</strong>: Use React DevTools Profiler to find actual bottlenecks before optimizing</li>
<li><strong>Don't Over-Memo</strong>: Only memoize components that actually have performance issues</li>
<li><strong>Bundle Analysis</strong>: Use webpack-bundle-analyzer to identify large dependencies</li>
<li><strong>Lazy Load Routes</strong>: Code-split at the route level for maximum impact</li>
<li><strong>Virtual Scrolling</strong>: Use for lists with 100+ items</li>
</ol>
<p><strong>Your app is now performance-optimized!</strong></p>4b:T4c3,<h3>createContext &amp; Context.Provider</h3>
<p>Share data without the prop drilling nightmare!</p>
<p>Context lets you share data across your component tree without manually passing props through every level. Think of it as a invisible tunnel that connects distant components - create the context, provide the data at the top, and consume it anywhere below.</p>
<pre class="language-javascript"><code>import { createContext, useContext } from 'react';

// Create a context with default value
const UserContext = createContext(null);

function App() {
  const user = { name: 'Alice', role: 'admin' }; // Your shared data
  
  return (
    // Provide the data to all child components
    &lt;UserContext.Provider value={user}&gt;
      &lt;Header /&gt;
      &lt;Dashboard /&gt;
    &lt;/UserContext.Provider&gt;
  );
}

function Dashboard() {
  const user = useContext(UserContext); // Access the shared data
  
  return (
    &lt;div&gt;
      &lt;h1&gt;Welcome, {user.name}!&lt;/h1&gt; {/* No props needed! */}
      &lt;p&gt;Role: {user.role}&lt;/p&gt;
    &lt;/div&gt;
  );
}</code></pre>
<p><strong>Context Superpower</strong>: Skip passing props through 10 levels of components!</p>4c:T48b,<p>The future of context consumption is here!</p>
<p>The new <code>use()</code> hook simplifies context consumption and works seamlessly with Server Components. It's more flexible than <code>useContext</code> and can handle both contexts and promises, making your code cleaner and more future-proof.</p>
<div>
<div>
<div>&nbsp;</div>
</div>
<div>
<pre class="language-markup"><code>import { use, createContext } from 'react';

// Your context setup
const ThemeContext = createContext('light');

function ThemeProvider({ children }) {
  return (
    // Provide theme data
    &lt;ThemeContext.Provider value="dark"&gt;
      {children}
    &lt;/ThemeContext.Provider&gt;
  );
}

function Button() {
  const theme = use(ThemeContext); // New way to consume context
  
  return (
    &lt;button 
      className={`btn btn-${theme}`} // Apply theme styling
      onClick={() =&gt; console.log('Clicked!')}
    &gt;
      I'm a {theme} button! {/* Dynamic content based on context */}
    &lt;/button&gt;
  );
}</code></pre>
</div>
</div>
<p><strong>Future-Ready</strong>: Works with both Client and Server Components seamlessly!</p>4d:T5f8,<p>Make your context data dynamic and interactive!</p>
<p>Context isn't just for static data - you can update it by including state setters in your context value. This creates a powerful pattern where any component can both read and modify shared state, perfect for things like user preferences, shopping carts, or theme toggles.</p>
<div>
<div>
<div>&nbsp;</div>
</div>
<div>
<pre class="language-javascript"><code>import { createContext, useState, useContext } from 'react';

// Create context for cart data
const CartContext = createContext();

function CartProvider({ children }) {
  const [items, setItems] = useState([]); // Local state for cart
  
  const addItem = (item) =&gt; setItems(prev =&gt; [...prev, item]); // Add function
  const removeItem = (id) =&gt; setItems(prev =&gt; prev.filter(i =&gt; i.id !== id)); // Remove function
  
  return (
    // Provide both data AND functions
    &lt;CartContext.Provider value={{ items, addItem, removeItem }}&gt;
      {children}
    &lt;/CartContext.Provider&gt;
  );
}

function ProductCard({ product }) {
  const { addItem } = useContext(CartContext); // Get the add function
  
  return (
    &lt;div&gt;
      &lt;h3&gt;{product.name}&lt;/h3&gt;
      &lt;button onClick={() =&gt; addItem(product)}&gt; {/* Update context */}
        Add to Cart
      &lt;/button&gt;
    &lt;/div&gt;
  );
}</code></pre>
</div>
</div>
<p><strong>Pro Pattern</strong>: Always include both data and updater functions in your context value!</p>4e:T655,<p>Stop playing "pass the props" through every component!</p>
<p>Prop drilling happens when you pass data through multiple component layers just to reach a deeply nested child. Context eliminates this by creating a direct connection between the data source and any component that needs it, no matter how deep in the tree.</p>
<div>
<div>
<div>&nbsp;</div>
</div>
<div>
<pre class="language-javascript"><code>import { createContext, useContext } from 'react';

// Create context for user preferences
const PreferencesContext = createContext();

function App() {
  const preferences = { 
    language: 'en', 
    currency: 'USD',
    notifications: true 
  };
  
  return (
    // Provide preferences at the top level
    &lt;PreferencesContext.Provider value={preferences}&gt;
      &lt;Layout /&gt;
    &lt;/PreferencesContext.Provider&gt;
  );
}

// Skip multiple intermediate components...
function Layout() {
  return (
    &lt;div&gt;
      &lt;Sidebar /&gt;
      &lt;MainContent /&gt;
    &lt;/div&gt;
  );
}

function MainContent() {
  return (
    &lt;div&gt;
      &lt;UserProfile /&gt; {/* No props passed here! */}
    &lt;/div&gt;
  );
}

function UserProfile() {
  const prefs = useContext(PreferencesContext); // Direct access!
  
  return (
    &lt;div&gt;
      &lt;p&gt;Language: {prefs.language}&lt;/p&gt; {/* Got the data! */}
      &lt;p&gt;Currency: {prefs.currency}&lt;/p&gt;
    &lt;/div&gt;
  );
}</code></pre>
</div>
</div>
<p><strong>Drilling Solution</strong>: Context creates a shortcut through your component tree!</p>
<h2>&nbsp;</h2>4f:T612,<p>Keep your context blazing fast with smart optimization!</p>
<p>Context can cause performance issues when the value changes frequently, triggering re-renders in all consuming components. Split contexts by update frequency, memoize context values, and use multiple contexts to minimize unnecessary re-renders.</p>
<div>
<div>
<div>&nbsp;</div>
</div>
<div>
<pre class="language-javascript"><code>import { createContext, useMemo, useState } from 'react';

// Split fast-changing and slow-changing data
const UserContext = createContext(); // Rarely changes
const NotificationContext = createContext(); // Changes frequently

function AppProvider({ children }) {
  const [user] = useState({ name: 'Alice' }); // Stable data
  const [notifications, setNotifications] = useState([]); // Frequent updates
  
  // Memoize context values to prevent unnecessary re-renders
  const userValue = useMemo(() =&gt; ({ user }), [user]);
  const notificationValue = useMemo(() =&gt; ({
    notifications,
    addNotification: (msg) =&gt; setNotifications(prev =&gt; [...prev, msg])
  }), [notifications]);
  
  return (
    // Separate providers for different update frequencies
    &lt;UserContext.Provider value={userValue}&gt;
      &lt;NotificationContext.Provider value={notificationValue}&gt;
        {children}
      &lt;/NotificationContext.Provider&gt;
    &lt;/UserContext.Provider&gt;
  );
}</code></pre>
</div>
</div>
<p><strong>Performance Win</strong>: Split contexts prevent unnecessary re-renders across your app!</p>50:T59a,<p>Catch JavaScript errors like a superhero safety net!</p>
<p>Error boundaries are React components that catch JavaScript errors anywhere in their child component tree and display a fallback UI instead of crashing the entire app. Think of them as try-catch blocks for React components - they prevent one broken component from destroying your whole application.</p>
<pre class="language-javascript"><code>import { Component } from 'react';

class ErrorBoundary extends Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false }; // Track error state
  }
  
  static getDerivedStateFromError(error) {
    return { hasError: true }; // Update state when error occurs
  }
  
  componentDidCatch(error, errorInfo) {
    console.error('Error caught:', error, errorInfo); // Log error details
  }
  
  render() {
    if (this.state.hasError) {
      return &lt;h2&gt;Something went wrong!&lt;/h2&gt;; // Show fallback UI
    }
    
    return this.props.children; // Render children normally
  }
}

// Wrap risky components
function App() {
  return (
    &lt;ErrorBoundary&gt;
      &lt;RiskyComponent /&gt; {/* If this crashes, show fallback */}
    &lt;/ErrorBoundary&gt;
  );
}</code></pre>
<p><strong>Safety First</strong>: Error boundaries prevent one bad component from crashing your entire app!</p>
<div>
<div>
<div>&nbsp;</div>
</div>
<div>&nbsp;</div>
</div>51:T63a,<p>Teleport your components anywhere in the DOM!</p>
<p>Portals let you render components outside their normal DOM hierarchy while maintaining React's event bubbling and context flow. Perfect for modals, tooltips, and dropdowns that need to escape overflow constraints or z-index issues - it's like having a teleportation device for your JSX!</p>
<div>
<div>
<div>&nbsp;</div>
</div>
<div>
<pre class="language-javascript"><code>import { createPortal } from 'react-dom';

function Modal({ isOpen, onClose, children }) {
  if (!isOpen) return null; // Don't render if closed
  
  // Portal renders outside the normal component tree
  return createPortal(
    &lt;div className="modal-overlay" onClick={onClose}&gt; {/* Backdrop */}
      &lt;div className="modal-content" onClick={e =&gt; e.stopPropagation()}&gt;
        {children} {/* Your modal content */}
        &lt;button onClick={onClose}&gt;Close&lt;/button&gt;
      &lt;/div&gt;
    &lt;/div&gt;,
    document.body // Render directly in body element
  );
}

function App() {
  const [showModal, setShowModal] = useState(false);
  
  return (
    &lt;div className="app"&gt;
      &lt;button onClick={() =&gt; setShowModal(true)}&gt;Open Modal&lt;/button&gt;
      
      &lt;Modal isOpen={showModal} onClose={() =&gt; setShowModal(false)}&gt;
        &lt;h2&gt;I'm rendered in document.body!&lt;/h2&gt; {/* Teleported! */}
      &lt;/Modal&gt;
    &lt;/div&gt;
  );
}</code></pre>
</div>
</div>
<p><strong>Portal Power</strong>: Render anywhere in the DOM while keeping React's magic intact!</p>52:T529,<p>Pass refs through components like a relay race!</p>
<p>forwardRef allows components to pass refs down to their child elements, enabling parent components to directly access child DOM nodes. This is essential for component libraries, form controls, and any time you need direct DOM access through component boundaries.</p>
<pre class="language-javascript"><code>import { forwardRef, useRef } from 'react';

// Component that forwards refs to its input
const CustomInput = forwardRef((props, ref) =&gt; {
  return (
    &lt;div className="custom-input-wrapper"&gt;
      &lt;label&gt;{props.label}&lt;/label&gt;
      &lt;input ref={ref} {...props} /&gt; {/* Forward ref to actual input */}
    &lt;/div&gt;
  );
});

function App() {
  const inputRef = useRef(); // Create ref in parent
  
  const focusInput = () =&gt; {
    inputRef.current.focus(); // Direct DOM access through forwarded ref
  };
  
  return (
    &lt;div&gt;
      &lt;CustomInput 
        ref={inputRef} 
        label="Name:" 
        placeholder="Enter your name" 
      /&gt;
      &lt;button onClick={focusInput}&gt;Focus Input&lt;/button&gt; {/* Control child directly */}
    &lt;/div&gt;
  );
}</code></pre>
<p><strong>Ref Relay</strong>: Forward refs to give parents direct access to child DOM elements!</p>53:T5b9,<p>Render on the server, ship less JavaScript to the client!</p>
<p>Server Components run on the server and send rendered HTML to the client, reducing bundle size and improving performance. They can directly access databases and APIs without client-side fetching, while still composing seamlessly with interactive Client Components for the best of both worlds.</p>
<div>
<div>
<div>&nbsp;</div>
</div>
<div>
<pre class="language-javascript"><code>// Server Component (runs on server)
async function UserProfile({ userId }) {
  // Direct database access (no API needed!)
  const user = await db.users.findById(userId);
  const posts = await db.posts.findByUserId(userId);
  
  return (
    &lt;div&gt;
      &lt;h1&gt;{user.name}&lt;/h1&gt; {/* Pre-rendered on server */}
      &lt;p&gt;Posts: {posts.length}&lt;/p&gt;
      
      {/* Mix server and client components */}
      &lt;InteractiveButton user={user} /&gt;
    &lt;/div&gt;
  );
}

// Client Component (runs in browser)
'use client'; // Mark as client component
function InteractiveButton({ user }) {
  const [liked, setLiked] = useState(false); // Client-side state
  
  return (
    &lt;button onClick={() =&gt; setLiked(!liked)}&gt;
      {liked ? '‚ù§Ô∏è' : 'ü§ç'} Like {user.name} {/* Interactive behavior */}
    &lt;/button&gt;
  );
}</code></pre>
</div>
</div>
<p><strong>Server Magic</strong>: Render on server for speed, add interactivity where needed!</p>54:T58d,<p>Handle forms and mutations directly on the server!</p>
<p>Server Actions are functions that run on the server and can be called directly from Client Components. They provide a seamless way to handle form submissions, data mutations, and server-side logic without building separate API endpoints - it's like having your backend functions available directly in your frontend code!</p>
<div>
<div>
<div>&nbsp;</div>
</div>
<div>
<pre class="language-javascript"><code>// Server Action (runs on server)
async function createPost(formData) {
  'use server'; // Mark as server action
  
  const title = formData.get('title'); // Extract form data
  const content = formData.get('content');
  
  // Direct database write
  await db.posts.create({ title, content, userId: getCurrentUserId() });
  
  redirect('/posts'); // Server-side redirect after success
}

// Client Component using Server Action
'use client';
function CreatePostForm() {
  return (
    &lt;form action={createPost}&gt; {/* Direct server action call */}
      &lt;input name="title" placeholder="Post title" required /&gt;
      &lt;textarea name="content" placeholder="Content" required /&gt;
      &lt;button type="submit"&gt;Create Post&lt;/button&gt; {/* Submits to server */}
    &lt;/form&gt;
  );
}</code></pre>
</div>
</div>
<p><strong>Action Hero</strong>: Call server functions directly from your components!</p>55:T686,<p>Build robust apps that gracefully handle the unexpected!</p>
<p>Error handling in React involves multiple layers: Error Boundaries for component errors, try-catch for async operations, and proper error states in your UI. Good error handling makes your app feel professional and helps users understand what went wrong and how to fix it.</p>
<div>
<div>
<div>&nbsp;</div>
</div>
<div>
<pre class="language-javascript"><code>import { useState } from 'react';

function DataFetcher() {
  const [data, setData] = useState(null);
  const [error, setError] = useState(null); // Track error state
  const [loading, setLoading] = useState(false);
  
  const fetchData = async () =&gt; {
    try {
      setLoading(true); // Start loading
      setError(null); // Clear previous errors
      
      const response = await fetch('/api/data');
      if (!response.ok) throw new Error('Failed to fetch'); // Handle HTTP errors
      
      const result = await response.json();
      setData(result); // Success - set data
    } catch (err) {
      setError(err.message); // Catch and display error
    } finally {
      setLoading(false); // Always stop loading
    }
  };
  
  if (loading) return &lt;div&gt;Loading...&lt;/div&gt;;
  if (error) return &lt;div&gt;Error: {error}&lt;/div&gt;; // Show error message
  
  return (
    &lt;div&gt;
      {data ? &lt;pre&gt;{JSON.stringify(data)}&lt;/pre&gt; : 'No data'}
      &lt;button onClick={fetchData}&gt;Fetch Data&lt;/button&gt;
    &lt;/div&gt;
  );
}</code></pre>
</div>
</div>
<p><strong>Error Strategy</strong>: Always handle loading, success, and error states for great UX!</p>56:T7ee,<p>Build forms that submit directly to your server functions!</p>
<p>Server Actions revolutionize form handling by eliminating the need for separate API endpoints. Forms can directly call server functions, handle validation server-side, and provide instant feedback while maintaining progressive enhancement - they work even without JavaScript!</p>
<div>
<div>
<div>&nbsp;</div>
</div>
<div>
<pre class="language-javascript"><code>// Server Action with validation
async function submitContactForm(prevState, formData) {
  'use server';
  
  const name = formData.get('name'); // Extract form fields
  const email = formData.get('email');
  const message = formData.get('message');
  
  // Server-side validation
  if (!name || !email || !message) {
    return { error: 'All fields are required' }; // Return error state
  }
  
  // Process form (save to database, send email, etc.)
  await saveContactMessage({ name, email, message });
  
  return { success: 'Message sent successfully!' }; // Return success state
}

// Client Component with Server Action
'use client';
import { useFormState } from 'react';

function ContactForm() {
  const [state, formAction] = useFormState(submitContactForm, null); // Hook for form state
  
  return (
    &lt;form action={formAction}&gt; {/* Connect to server action */}
      &lt;input name="name" placeholder="Your name" required /&gt;
      &lt;input name="email" type="email" placeholder="Your email" required /&gt;
      &lt;textarea name="message" placeholder="Your message" required /&gt;
      
      &lt;button type="submit"&gt;Send Message&lt;/button&gt;
      
      {state?.error &amp;&amp; &lt;p style={{color: 'red'}}&gt;{state.error}&lt;/p&gt;} {/* Show errors */}
      {state?.success &amp;&amp; &lt;p style={{color: 'green'}}&gt;{state.success}&lt;/p&gt;} {/* Show success */}
    &lt;/form&gt;
  );
}</code></pre>
</div>
</div>
<p><strong>Form Revolution</strong>: Server Actions make form handling simple and powerful!</p>57:T7a0,<p>Harness React's concurrent features for buttery smooth user experiences!</p>
<p>Concurrent rendering allows React to pause, resume, and prioritize work, preventing blocking the main thread during heavy computations. Combined with Suspense boundaries and transitions, you can create apps that stay responsive even during complex updates and data loading scenarios.</p>
<div>
<div>
<div>&nbsp;</div>
</div>
<div>
<pre class="language-javascript"><code>import { startTransition, useDeferredValue, Suspense } from 'react';

function SearchApp() {
  const [query, setQuery] = useState('');
  const [isPending, startTransition] = useTransition(); // Handle non-urgent updates
  const deferredQuery = useDeferredValue(query); // Defer expensive updates
  
  const handleSearch = (newQuery) =&gt; {
    setQuery(newQuery); // Immediate update for input
    
    startTransition(() =&gt; {
      // Mark expensive update as non-urgent
      performExpensiveSearch(newQuery);
    });
  };
  
  return (
    &lt;div&gt;
      &lt;input 
        value={query} 
        onChange={(e) =&gt; handleSearch(e.target.value)}
        placeholder="Search..."
      /&gt;
      
      {isPending &amp;&amp; &lt;div&gt;Searching...&lt;/div&gt;} {/* Show loading for transitions */}
      
      &lt;Suspense fallback={&lt;div&gt;Loading results...&lt;/div&gt;}&gt;
        &lt;SearchResults query={deferredQuery} /&gt; {/* Use deferred value */}
      &lt;/Suspense&gt;
    &lt;/div&gt;
  );
}

function SearchResults({ query }) {
  const results = use(searchAPI(query)); // Suspend until data loads
  
  return (
    &lt;div&gt;
      {results.map(result =&gt; (
        &lt;div key={result.id}&gt;{result.title}&lt;/div&gt; // Render when ready
      ))}
    &lt;/div&gt;
  );
}</code></pre>
</div>
</div>
<p><strong>Concurrent Magic</strong>: Keep your UI responsive during heavy work with smart prioritization!</p>4:["$","main",null,{"className":"w-full min-h-screen pt-5 px-2 pb-6 md:pb-8 bg-[linear-gradient(135deg,_#8F87F1_-50%,_#f8fafc_100%)] dark:bg-[linear-gradient(135deg,_#7A70D8_-50%,_#d1d5db_100%)]","children":[["$","div",null,{"className":"sm:hidden md:block w-full flex justify-center mb-2","children":["$","a",null,{"href":"https://github.com/llaryall/ReactJS-CheatSheet","target":"_blank","rel":"noopener noreferrer","aria-label":"GitHub Profile","children":["$","$L12",null,{"src":"./github.svg","alt":"GitHub","className":"h-8 w-8 hover:scale-110 transition-transform","width":32,"height":32,"style":{"minWidth":24,"minHeight":24}}]}]}],["$","div",null,{"className":"w-full flex justify-center","children":["$","div",null,{"className":"w-full max-w-sm sm:max-w-md md:max-w-xl lg:max-w-2xl xl:max-w-3xl bg-white/10 dark:bg-slate-800/20 backdrop-blur-md rounded-xl p-3 sm:p-4 md:p-6 shadow-lg flex flex-col items-center mt-2 mb-6 md:mb-8","children":[["$","h1",null,{"className":"text-lg sm:text-xl md:text-2xl lg:text-3xl font-bold text-[#3D3D3D] dark:text-gray-100 mb-2 md:mb-4 text-center leading-tight truncate","children":"ReactJS Cheatsheet"}],["$","p",null,{"className":"text-xs sm:text-sm md:text-md text-[#3D3D3D]/80 dark:text-gray-300/90 flex flex-row flex-wrap items-center justify-center gap-4 md:gap-8","children":[["$","span",null,{"className":"font-semibold text-center sm:text-left","children":["$","span",null,{"className":"text-green-600 dark:text-green-400","children":["üü¢ Beginner"," "]}]}],["$","span",null,{"className":"font-semibold text-center sm:text-left","children":["$","span",null,{"className":"text-blue-600 dark:text-blue-400","children":["üîµ Common Use"," "]}]}],["$","span",null,{"className":"font-semibold text-center sm:text-left","children":["$","span",null,{"className":"text-purple-600 dark:text-purple-400","children":["üü£ Advanced"," "]}]}]]}]]}]}],["$","$L13",null,{"initialCategories":[{"collectionId":"pbc_484971879","collectionName":"Categories","created":"2025-05-26 11:05:01.658Z","desription":"Foundation of how React works, JSX, and rendering concepts.","display_order":1,"id":"8x5x2ierbnat38n","name":"Core Fundamentals & Rendering","slug":"core fundamentals & rendering","updated":"2025-05-26 13:14:19.228Z","topics":[{"id":"m39p41t8203fh7e","title":"What is React?","slug":"what is react?","tier":"üü¢","description":"<h3>What is React?</h3>\r\n<p>React is a <strong>UI Library</strong> for building user interfaces in JavaScript. It's built around three core principles:</p>\r\n<p><strong>UI Library (Not a Framework)</strong> React focuses solely on the view layer - it handles how your app looks and responds to user interactions, but doesn't dictate how you handle routing, data fetching, or other concerns.</p>\r\n<p><strong>Declarative</strong> You describe <em>what</em> the UI should look like for any given state, rather than <em>how</em> to manipulate the DOM step by step.</p>\r\n<div>\r\n<div>\r\n<div>&nbsp;</div>\r\n</div>\r\n<div>\r\n<pre class=\"language-javascript\"><code>// Declarative - describe what you want\r\nfunction Status({ isOnline }) {\r\n  return &lt;div&gt;{isOnline ? \"Online\" : \"Offline\"}&lt;/div&gt;;\r\n}</code></pre>\r\n</div>\r\n</div>\r\n<p><strong>Component-Based</strong> UIs are built from small, reusable pieces called components that manage their own logic and can be combined to create complex interfaces.</p>"},{"id":"19zkdhy2f7cf4zd","title":"JSX: syntax, curly braces, className","slug":"jsx: syntax, curly braces, className","tier":"üü¢","description":"$14"},{"id":"20v88p6j7ms8mn7","title":"Functional Components: syntax and why they're used","slug":"functional components: syntax and why they're used","tier":"üü¢","description":"$15"},{"id":"l639f1n6ff501hj","title":"Props: how to pass data (parent to child)","slug":"props: how to pass data (parent to child)","tier":"üü¢","description":"$16"},{"id":"7a945d091712zoo","title":"props.children and Composition","slug":"props.children and composition","tier":"üîµ","description":"$17"},{"id":"czwr6ne0697rf04","title":"Fragments and Self-Closing Tags","slug":"fragments and self-closing tags","tier":"üîµ","description":"$18"},{"id":"jtw07v3t051js13","title":"Default Props","slug":"default props","tier":"üîµ","description":"$19"},{"id":"kwt717y08jv1z8b","title":"Virtual DOM Basics","slug":"virtual dOM basics","tier":"üîµ","description":"$1a"},{"id":"nrysg9466r7kq08","title":"Reconciliation Algorithm","slug":"reconciliation algorithm","tier":"üü£","description":"$1b"},{"id":"0ek93n05fv60e4f","title":"Fiber Architecture","slug":"fiber architecture","tier":"üü£","description":"$1c"},{"id":"32va4h4t01867g2","title":"Keys in Lists","slug":"keys in lists","tier":"üü£","description":"$1d"},{"id":"s6j82d198z150xq","title":"Elements, Components, and Instances","slug":"elements, components, and instances","tier":"üü£","description":"$1e"}]},{"collectionId":"pbc_484971879","collectionName":"Categories","created":"2025-05-26 14:03:37.465Z","desription":"How state works and flows in components.","display_order":2,"id":"2tvh97u47flbrr6","name":"State Management ","slug":"state management ","updated":"2025-05-27 16:04:35.734Z","topics":[{"id":"yol095kw1uut212","title":"What is state in React?","slug":"what is state in react?","tier":"üü¢","description":"$1f"},{"id":"1hm1n8yt3g608z3","title":"Local Component State Concepts","slug":"local component state concepts","tier":"üü¢","description":"$20"},{"id":"7i685dnazadp1w0","title":"Lifting State Up","slug":"lifting state up","tier":"üîµ","description":"$21"},{"id":"r3m280sv033pnwy","title":"Colocation of State","slug":"colocation of state","tier":"üîµ","description":"$22"},{"id":"1goik3306k97st1","title":"Form State Basics","slug":"form state basics","tier":"üîµ","description":"$23"},{"id":"48487y5b7fk2q55","title":"Immutable update patterns","slug":"Immutable update patterns","tier":"üü£","description":"$24"},{"id":"979rhqmj109t73x","title":"Context API Introduction","slug":"context API introduction","tier":"üü£","description":"$25"},{"id":"9ov18o09138p684","title":"useState, useReducer, or Lifting State Up","slug":"useState, useReducer, or lifting state up","tier":"üü£","description":"$26"}]},{"collectionId":"pbc_484971879","collectionName":"Categories","created":"2025-05-26 21:25:20.604Z","desription":"Understanding component life and when things happen.","display_order":3,"id":"9vgrctduw96b9a6","name":"Lifecycle & Side Effects","slug":"lifecycle & side effects","updated":"2025-05-26 21:25:20.604Z","topics":[{"id":"k3etioj3w1ix5qq","title":"Lifecycle Phases","slug":"lifecycle phases","tier":"üü¢","description":"$27"},{"id":"u2e060155he207n","title":"What are Side Effects? ","slug":"what are side effects? ","tier":"üü¢","description":"<p>Side effects are things your component does <strong>beyond</strong> just returning JSX. Think of them as the \"extra stuff\" that happens:</p>\r\n<p><strong>Common Side Effects:</strong></p>\r\n<ul>\r\n<li>üåê <strong>Fetching data</strong> from APIs</li>\r\n<li>‚è∞ <strong>Setting up timers</strong> or intervals</li>\r\n<li>üìù <strong>Updating document title</strong></li>\r\n<li>üéß <strong>Adding event listeners</strong></li>\r\n<li>üíæ&nbsp;<strong>Saving to localStorage</strong></li>\r\n</ul>\r\n<pre class=\"language-javascript\"><code>function UserProfile({ userId }) {\r\n  const [user, setUser] = useState(null);\r\n  \r\n  useEffect(() =&gt; {\r\n    // Side effect: Fetching data\r\n    async function fetchUser() {\r\n      const response = await fetch(`/api/users/${userId}`);\r\n      const userData = await response.json();\r\n      setUser(userData);\r\n    }\r\n    \r\n    fetchUser();\r\n  }, [userId]);\r\n  \r\n  return user ? &lt;h1&gt;Hello, {user.name}!&lt;/h1&gt; : &lt;div&gt;Loading...&lt;/div&gt;;\r\n}</code></pre>"},{"id":"4bje56469lban06","title":"Cleanup in Effects","slug":"cleanup in effects","tier":"üîµ","description":"$28"},{"id":"o360l670j2pa1bh","title":"Effects After Render","slug":"effects after render","tier":"üîµ","description":"<p>Effects run <strong>after</strong> the DOM has been updated - like adding the final touches to a painting!</p>\r\n<div>\r\n<div>\r\n<div>&nbsp;</div>\r\n</div>\r\n<div>\r\n<pre class=\"language-javascript\"><code>function FocusInput() {\r\n  const inputRef = useRef(null);\r\n  \r\n  useEffect(() =&gt; {\r\n    // This runs AFTER the component renders\r\n    // DOM is ready, so we can focus the input\r\n    inputRef.current.focus();\r\n    console.log(\"Input focused after render! ‚ú®\");\r\n  }, []);\r\n  \r\n  return &lt;input ref={inputRef} placeholder=\"I'll be focused!\" /&gt;;\r\n}\r\n</code></pre>\r\n</div>\r\n</div>\r\n<p><strong>Render Order:</strong></p>\r\n<ol>\r\n<li>Component renders JSX üèóÔ∏è</li>\r\n<li>DOM gets updated üîÑ</li>\r\n<li>useEffect runs üéØ</li>\r\n<li>Browser paints the screen üé®</li>\r\n</ol>"},{"id":"hj377256m20ql4f","title":"Async Effects and Race Conditions","slug":"async effects and race conditions","tier":"üü£","description":"$29"},{"id":"m9o3966pl5gav03","title":"Execution Timing and Batching","slug":"execution timing and batching","tier":"üü£","description":"$2a"}]},{"collectionId":"pbc_484971879","collectionName":"Categories","created":"2025-05-28 08:29:47.873Z","desription":"A central place for all hook knowledge.","display_order":3,"id":"p2z33h6df0yk8wa","name":"Hooks (Core + Library Hooks)","slug":"hooks (core + library Hooks)","updated":"2025-05-28 08:29:47.873Z","topics":[{"id":"41hk803n0xvu75w","title":"useReducer","slug":"usereducer","tier":"üîµ","description":"<p>Manage complex state with actions! Like a state machine.</p>\r\n<pre class=\"language-javascript\"><code>function Counter() {\r\n  const [count, dispatch] = useReducer((state, action) =&gt; { // Create reducer with current state and action\r\n    if (action.type === 'add') return state + 1; // If action is 'add', increase state by 1\r\n    if (action.type === 'reset') return 0; // If action is 'reset', set state to 0\r\n    return state; // Otherwise, keep state the same\r\n  }, 0); // Start with initial state of 0\r\n  \r\n  return ( // Return JSX\r\n    &lt;div&gt;\r\n      &lt;p&gt;{count}&lt;/p&gt; {/* Display current count */}\r\n      &lt;button onClick={() =&gt; dispatch({type: 'add'})}&gt; {/* Send 'add' action when clicked */}\r\n        Add {/* Button text */}\r\n      &lt;/button&gt;\r\n      &lt;button onClick={() =&gt; dispatch({type: 'reset'})}&gt; {/* Send 'reset' action when clicked */}\r\n        Reset {/* Button text */}\r\n      &lt;/button&gt;\r\n    &lt;/div&gt;\r\n  );\r\n}</code></pre>"},{"id":"6tll1cp81g12aph","title":"What are Hooks?","slug":"what are hooks?","tier":"üü¢","description":"<p>Hooks are like <strong>magic powers</strong> for your components! They let you \"hook into\" React's features without writing class components.</p>\r\n<p><strong>Think of hooks as:</strong></p>\r\n<ul>\r\n<li>üîå <strong>Plugging into</strong> React's power</li>\r\n<li>üé™ <strong>Special functions</strong> that start with \"use\"</li>\r\n<li>‚ú® <strong>Superpowers</strong> for functional components</li>\r\n</ul>\r\n<div>\r\n<div>\r\n<div>&nbsp;</div>\r\n</div>\r\n<div>\r\n<pre class=\"language-javascript\"><code>function MyComponent() {\r\n  const [count, setCount] = useState(0); // Create a state variable called 'count' starting at 0\r\n  return ( // Return JSX to display\r\n    &lt;button onClick={() =&gt; setCount(count + 1)}&gt; {/* When clicked, increase count by 1 */}\r\n      {count} {/* Show the current count value */}\r\n    &lt;/button&gt;\r\n  );\r\n}</code></pre>\r\n</div>\r\n</div>"},{"id":"8a7l14jhkr115ia","title":"useContext","slug":"usecontext","tier":"üîµ","description":"<p>Share data without prop drilling! Like a family group chat everyone can access.</p>\r\n<pre class=\"language-javascript\"><code>const ThemeContext = createContext(); // Create a context to share theme data\r\n\r\nfunction App() {\r\n  return ( // Return JSX with context provider\r\n    &lt;ThemeContext.Provider value=\"dark\"&gt; {/* Provide \"dark\" theme to all children */}\r\n      &lt;Header /&gt; {/* Header can access theme without props! */}\r\n    &lt;/ThemeContext.Provider&gt;\r\n  );\r\n}\r\n\r\nfunction Header() {\r\n  const theme = useContext(ThemeContext); // Get theme value from context - returns \"dark\"\r\n  return &lt;h1 className={theme}&gt;Hello!&lt;/h1&gt;; // Use theme as CSS class\r\n}</code></pre>\r\n<h3>&nbsp;</h3>"},{"id":"d6p4uyn2z2128lg","title":"Rules of Hooks","slug":"rules of hooks","tier":"üü¢","description":"$2b"},{"id":"x617sh002wbu77b","title":"useState","slug":"usestate","tier":"üü¢","description":"<p>Your component's memory! Like a sticky note that remembers things.</p>\r\n<pre class=\"language-markup\"><code>function Counter() {\r\n  const [count, setCount] = useState(0); // Create state: count starts at 0, setCount updates it\r\n  \r\n  return ( // Return JSX to display\r\n    &lt;div&gt;\r\n      &lt;p&gt;Count: {count}&lt;/p&gt; {/* Show current count value */}\r\n      &lt;button onClick={() =&gt; setCount(count + 1)}&gt; {/* When clicked, add 1 to count */}\r\n        Add 1 {/* Button text */}\r\n      &lt;/button&gt;\r\n    &lt;/div&gt;\r\n  );\r\n}</code></pre>\r\n<p><strong>Different starting values:</strong></p>\r\n<pre class=\"language-javascript\"><code>const [name, setName] = useState(\"\"); // String state starts empty\r\nconst [items, setItems] = useState([]); // Array state starts empty\r\nconst [isOpen, setIsOpen] = useState(false); // Boolean state starts false\r\nconst [user, setUser] = useState(null); // Object state starts null (for loading)</code></pre>\r\n<p>&nbsp;</p>"},{"id":"pd505i2xuw7eax9","title":"use","slug":"use","tier":"üü¢","description":"<p>The revolutionary hook that can handle promises and context! Game changer!</p>\r\n<div>\r\n<pre class=\"language-javascript\"><code>function UserProfile({ userPromise }) {\r\n  const user = use(userPromise); // Wait for promise to resolve - suspends component until ready\r\n  \r\n  return &lt;div&gt;Hello, {user.name}!&lt;/div&gt;; // Display user data when promise resolves\r\n}\r\n\r\nfunction ThemeButton() {\r\n  const theme = use(ThemeContext); // Get context value - same as useContext but can be conditional!\r\n  \r\n  return &lt;button className={theme}&gt;Themed Button&lt;/button&gt;; // Use theme from context\r\n}</code></pre>\r\n</div>"},{"id":"8y3d8j684n96945","title":"useEffect","slug":"useEffect","tier":"üü¢","description":"$2c"},{"id":"5vd5p29581clsl6","title":"useId","slug":"useid","tier":"üü¢","description":"<p>Generate unique IDs for accessibility! Like getting a unique number at the bakery.</p>\r\n<pre class=\"language-javascript\"><code>function LoginForm() {\r\n  const id = useId(); // Generate unique ID like \":r1:\"\r\n  \r\n  return ( // Return JSX form\r\n    &lt;div&gt;\r\n      &lt;label htmlFor={id}&gt;Email:&lt;/label&gt; {/* Label points to input using ID */}\r\n      &lt;input id={id} type=\"email\" /&gt; {/* Input has the same ID - screen readers connect them! */}\r\n    &lt;/div&gt;\r\n  );\r\n}</code></pre>"},{"id":"d7hg2yg52e6oh35","title":"useRef","slug":"useref","tier":"üîµ","description":"<p>Point to DOM elements or keep values that don't cause re-renders!</p>\r\n<pre class=\"language-javascript\"><code>function FocusInput() {\r\n  const inputRef = useRef(null); // Create a reference that starts as null\r\n  \r\n  const focusInput = () =&gt; { // Function to focus the input\r\n    inputRef.current.focus(); // Access the DOM element and focus it\r\n  };\r\n  \r\n  return ( // Return JSX\r\n    &lt;div&gt;\r\n      &lt;input ref={inputRef} /&gt; {/* Attach the ref to this input element */}\r\n      &lt;button onClick={focusInput}&gt;Focus!&lt;/button&gt; {/* Button calls focusInput when clicked */}\r\n    &lt;/div&gt;\r\n  );\r\n}</code></pre>"},{"id":"93x4ln0a93m0qmk","title":"useCallback, useMemo","slug":"usecallback, usememo","tier":"üîµ","description":"<p>Performance boosters! Save expensive calculations and functions.</p>\r\n<pre class=\"language-javascript\"><code>function ExpensiveComponent({ items, filter }) { // Component receives items and filter as props\r\n  // Only recalculate when items or filter change\r\n  const filteredItems = useMemo(() =&gt; { // useMemo prevents unnecessary recalculation\r\n    return items.filter(item =&gt; item.includes(filter)); // Filter items that contain the filter text\r\n  }, [items, filter]); // Only recalculate if items or filter change\r\n  \r\n  // Only recreate function when filter changes\r\n  const handleClick = useCallback(() =&gt; { // useCallback prevents function recreation\r\n    console.log(`Filtering by: ${filter}`); // Log current filter value\r\n  }, [filter]); // Only recreate function if filter changes\r\n  \r\n  return &lt;div&gt;{filteredItems.length} items&lt;/div&gt;; // Display number of filtered items\r\n}</code></pre>"},{"id":"lytl7eg0fl07vk2","title":"useActionState","slug":"useactionstate","tier":"üü¢","description":"<p>Handle form actions with loading states! Perfect for server actions.</p>\r\n<pre class=\"language-javascript\"><code>function ContactForm() {\r\n  const [state, formAction, isPending] = useActionState(\r\n    async (prevState, formData) =&gt; { // Server action function\r\n      const email = formData.get('email'); // Get email from form data\r\n      const result = await sendEmail(email); // Send email to server\r\n      return result; // Return result to update state\r\n    },\r\n    null // Initial state\r\n  );\r\n  \r\n  return ( // Return form JSX\r\n    &lt;form action={formAction}&gt; {/* Form uses server action */}\r\n      &lt;input name=\"email\" type=\"email\" /&gt; {/* Email input */}\r\n      &lt;button disabled={isPending}&gt; {/* Button disabled while sending */}\r\n        {isPending ? 'Sending...' : 'Send Email'} {/* Show loading text */}\r\n      &lt;/button&gt;\r\n      {state?.error &amp;&amp; &lt;p&gt;Error: {state.error}&lt;/p&gt;} {/* Show error if exists */}\r\n    &lt;/form&gt;\r\n  );\r\n}</code></pre>"},{"id":"35r424k56u6e6gw","title":"useOptimistic","slug":"useoptimistic","tier":"üü¢","description":"$2d"},{"id":"2s77f3x4pe658j3","title":"useSyncExternalStore","slug":"usesyncexternalstore","tier":"üîµ","description":"<p>Connect to external data sources! Like subscribing to a newsletter.</p>\r\n<pre class=\"language-javascript\"><code>function WindowWidth() {\r\n  const width = useSyncExternalStore( // Connect to external window width data\r\n    (callback) =&gt; { // Subscribe function - tells React how to listen for changes\r\n      window.addEventListener('resize', callback); // Listen for window resize events\r\n      return () =&gt; window.removeEventListener('resize', callback); // Cleanup function\r\n    },\r\n    () =&gt; window.innerWidth // Get current value function - returns current window width\r\n  );\r\n  \r\n  return &lt;div&gt;Width: {width}px&lt;/div&gt;; // Display current window width\r\n}</code></pre>"},{"id":"gi9b9510d403d7i","title":"useImperativeHandle ","slug":"useImperativehandle ","tier":"üü£","description":"<p>Customize what parent components can do to your component.</p>\r\n<div>\r\n<pre class=\"language-javascript\"><code>const FancyInput = forwardRef((props, ref) =&gt; { // Create component that forwards refs\r\n  const inputRef = useRef(); // Create reference to the actual input element\r\n  \r\n  useImperativeHandle(ref, () =&gt; ({ // Define what parent can do with this component\r\n    focus: () =&gt; inputRef.current.focus(), // Custom focus method\r\n    clear: () =&gt; inputRef.current.value = '' // Custom clear method\r\n  }));\r\n  \r\n  return &lt;input ref={inputRef} /&gt;; // Return input with attached ref\r\n});</code></pre>\r\n</div>"},{"id":"3ub8mu959olo39r","title":"useLayoutEffect","slug":"uselayoutffect ","tier":"üü£","description":"<p>Like <code>useEffect</code> but runs <strong>before</strong> the browser paints! For DOM measurements.</p>\r\n<pre class=\"language-javascript\"><code>function MeasureDiv() {\r\n  const divRef = useRef(); // Create reference to the div element\r\n  const [height, setHeight] = useState(0); // Create state to store height\r\n  \r\n  useLayoutEffect(() =&gt; { // Runs before browser paints the screen\r\n    setHeight(divRef.current.offsetHeight); // Measure div height and update state\r\n  }); // No dependency array = runs after every render\r\n  \r\n  return &lt;div ref={divRef}&gt;Height: {height}px&lt;/div&gt;; // Display div with its height\r\n}</code></pre>"},{"id":"9b7471wgwb0pkqy","title":"useDebugValue ","slug":"usedebugvalue ","tier":"üü£","description":"<p>Show custom labels in React DevTools for custom hooks.</p>\r\n<div>\r\n<pre class=\"language-javascript\"><code>function useCounter(initialValue = 0) { // Custom hook with default parameter\r\n  const [count, setCount] = useState(initialValue); // Create count state\r\n  \r\n  useDebugValue(count &gt; 5 ? 'High' : 'Low'); // Show \"High\" or \"Low\" in React DevTools\r\n  \r\n  return [count, setCount]; // Return count and setter function\r\n}</code></pre>\r\n</div>"},{"id":"ytc005n55o6c6ir","title":"Creating Custom Hooks ","slug":"creating custom hooks ","tier":"üü£","description":"<p>Make your own hooks! Follow the \"use\" naming convention.</p>\r\n<pre class=\"language-javascript\"><code>function useToggle(initialValue = false) { // Custom hook with default parameter\r\n  const [value, setValue] = useState(initialValue); // Create boolean state\r\n  \r\n  const toggle = () =&gt; setValue(!value); // Function to flip the boolean value\r\n  \r\n  return [value, toggle]; // Return current value and toggle function (like useState pattern)\r\n}\r\n\r\n// Usage\r\nfunction App() {\r\n  const [isOpen, toggleOpen] = useToggle(); // Use custom hook - isOpen starts false\r\n  \r\n  return ( // Return JSX\r\n    &lt;div&gt;\r\n      &lt;button onClick={toggleOpen}&gt; {/* Button calls toggle function when clicked */}\r\n        {isOpen ? 'Close' : 'Open'} {/* Show 'Close' if open, 'Open' if closed */}\r\n      &lt;/button&gt;\r\n    &lt;/div&gt;\r\n  );\r\n}</code></pre>"},{"id":"i2mij959a0wl7ci","title":"useTransition, useDeferredValue ","slug":"usetransition, usedeferredvalue ","tier":"üü£","description":"$2e"},{"id":"imw1c4ot14t4u9a","title":"useFormState ","slug":"useformstate ","tier":"üü£","description":"<p>one of React 19 Server Component Hooks&nbsp;</p>\r\n<p>Handle server actions with state (renamed from useActionState)</p>\r\n<pre class=\"language-javascript\"><code>function SearchForm() {\r\n  const [state, formAction] = useFormState(\r\n    async (prevState, formData) =&gt; { // Server action\r\n      const query = formData.get('query'); // Get search query from form\r\n      const results = await searchAPI(query); // Search on server\r\n      return { results, query }; // Return new state\r\n    },\r\n    { results: [], query: '' } // Initial state\r\n  );\r\n  \r\n  return ( // Return form JSX\r\n    &lt;form action={formAction}&gt; {/* Form calls server action */}\r\n      &lt;input name=\"query\" defaultValue={state.query} /&gt; {/* Search input */}\r\n      &lt;button&gt;Search&lt;/button&gt; {/* Submit button */}\r\n      &lt;div&gt;Found {state.results.length} results&lt;/div&gt; {/* Show result count */}\r\n    &lt;/form&gt;\r\n  );\r\n}\r\n</code></pre>"},{"id":"zxgy40rc53u75el","title":"useFormStatus","slug":"useformstatus","tier":"üü£","description":"<p>one of React 19 Server Component Hooks</p>\r\n<p>Track form submission status</p>\r\n<div>\r\n<div>\r\n<div>&nbsp;</div>\r\n</div>\r\n<div>\r\n<pre class=\"language-javascript\"><code>function SubmitButton() {\r\n  const { pending, data, method, action } = useFormStatus(); // Get current form status\r\n  \r\n  return ( // Return button JSX\r\n    &lt;button disabled={pending}&gt; {/* Disable button while form is submitting */}\r\n      {pending ? 'Submitting...' : 'Submit'} {/* Show loading text while pending */}\r\n    &lt;/button&gt;\r\n  );\r\n}</code></pre>\r\n</div>\r\n</div>"}]},{"collectionId":"pbc_484971879","collectionName":"Categories","created":"2025-05-28 08:30:21.980Z","desription":"How data moves through React and useful patterns.","display_order":4,"id":"o2hxc53ous8mv2r","name":"Data Flow & Patterns","slug":"data flow & patterns","updated":"2025-05-28 08:30:21.980Z","topics":[{"id":"8q0htc2l5e60il4","title":"Component Composition","slug":"component composition","tier":"üîµ","description":"$2f"},{"id":"rxg12593r9who27","title":" One-Way Data Flow","slug":" One-way data flow","tier":"üü¢","description":"$30"},{"id":"5s55z0a6mdsv7y2","title":" Props (Properties)","slug":" props (properties)","tier":"üü¢","description":"$31"},{"id":"k873rcz6mv416fa","title":" State vs Props","slug":" state vs props","tier":"üü¢","description":"$32"},{"id":"6o7208h47t6kdy6","title":"Event Handling","slug":"event handling","tier":"üü¢","description":"$33"},{"id":"36c272sy5of91i0","title":"Conditional Rendering","slug":"conditional rendering","tier":"üîµ","description":"$34"},{"id":"1i5p463wr2l8uyg","title":"Rendering Lists with Keys","slug":"rendering lists with keys","tier":"üîµ","description":"$35"},{"id":"8jlu6x87avz08o0","title":"Controlled Forms","slug":"controlled forms","tier":"üîµ","description":"$36"},{"id":"001l4171pl6wl1y","title":"Render Props","slug":"render props ","tier":"üü£","description":"$37"},{"id":"9qaevc25p7eh6t2","title":"Lifting State Up","slug":"lifting state up","tier":"üîµ","description":"$38"},{"id":"i8k48yw03d10wbh","title":"HOCs (Higher Order Components)","slug":"HOCs (higher order components)","tier":"üü£","description":"$39"},{"id":"201515u67757901","title":"Advanced Form Validation","slug":"advanced form validation","tier":"üü£","description":"$3a"},{"id":"305w82hx262673v","title":"Data Fetching Patterns","slug":"data fetching patterns","tier":"üü£","description":"$3b"},{"id":"9lh1627862re881","title":"Server Actions (React 19)","slug":"server actions (react 19)","tier":"üü£","description":"$3c"}]},{"collectionId":"pbc_484971879","collectionName":"Categories","created":"2025-05-28 08:30:49.984Z","desription":"Client-side navigation with React Router.","display_order":5,"id":"8ifb48zll7m39cg","name":"Routing & Navigation","slug":"routing & navigation","updated":"2025-05-28 08:30:49.984Z","topics":[{"id":"qr057x565g75o1d","title":"What is Client-Side Routing?","slug":"what is client-side routing?","tier":"üü¢","description":"<p>Think of your React app as a <strong>magic book</strong> üìö where pages change instantly without reloading! Instead of asking the server for new HTML every time, React Router lets you:</p>\r\n<ul>\r\n<li>Switch between \"pages\" instantly ‚ö°</li>\r\n<li>Keep your app state alive üß†</li>\r\n<li>Create smooth user experiences ‚ú®</li>\r\n</ul>\r\n<p><strong>Traditional routing</strong>: Click link &rarr; Server sends new page &rarr; Page reloads üò¥<br><strong>Client-side routing</strong>: Click link &rarr; JavaScript shows new content &rarr; No reload! üéâ</p>"},{"id":"qw2tib56p263fw1","title":"createBrowserRouter","slug":"createbrowserrouter","tier":"üü¢","description":"<p><em>The modern way to set up routing!</em></p>\r\n<div>\r\n<div>\r\n<div>&nbsp;</div>\r\n</div>\r\n<div>\r\n<pre class=\"language-javascript\"><code>import { createBrowserRouter, RouterProvider } from 'react-router-dom';\r\n\r\n// Create your router configuration - like a roadmap for your app!\r\nconst router = createBrowserRouter([\r\n  {\r\n    path: \"/\",           // The URL path users will see\r\n    element: &lt;Home /&gt;,   // What component to show\r\n  },\r\n  {\r\n    path: \"/about\",      // Another route\r\n    element: &lt;About /&gt;,  // Another component\r\n  },\r\n]);\r\n\r\n// Your main App component\r\nfunction App() {\r\n  return (\r\n    &lt;RouterProvider router={router} /&gt; // Give your app the routing superpowers!\r\n  );\r\n}</code></pre>\r\n</div>\r\n</div>"},{"id":"ciebk58flj46al9","title":"Routes, Route, Link","slug":"routes, route, link","tier":"üü¢","description":"<p><em>The classic trio for basic routing</em></p>\r\n<div>\r\n<pre class=\"language-javascript\"><code>import { BrowserRouter, Routes, Route, Link } from 'react-router-dom';\r\n\r\nfunction App() {\r\n  return (\r\n    &lt;BrowserRouter&gt; {/* Enables routing for your entire app */}\r\n      \r\n      {/* Navigation menu */}\r\n      &lt;nav&gt;\r\n        &lt;Link to=\"/\"&gt;Home&lt;/Link&gt;        {/* Creates clickable links */}\r\n        &lt;Link to=\"/about\"&gt;About&lt;/Link&gt;  {/* No page refresh! */}\r\n      &lt;/nav&gt;\r\n\r\n      {/* Define which component shows for each URL */}\r\n      &lt;Routes&gt;\r\n        &lt;Route path=\"/\" element={&lt;Home /&gt;} /&gt;       {/* Show Home at \"/\" */}\r\n        &lt;Route path=\"/about\" element={&lt;About /&gt;} /&gt; {/* Show About at \"/about\" */}\r\n      &lt;/Routes&gt;\r\n      \r\n    &lt;/BrowserRouter&gt;\r\n  );\r\n}</code></pre>\r\n</div>"},{"id":"ulmg7s5y5p5rhmi","title":"Nested Routes (<Outlet />)","slug":"Nested Routes (<Outlet />)","tier":"üîµ","description":"$3d"},{"id":"7cpp38495328b9y","title":"Dynamic Routes (:id)","slug":"dynamic routes (:id)","tier":"üîµ","description":"<p><em>Capture changing parts of URLs - like catching Pokemon with different IDs!</em></p>\r\n<div>\r\n<pre class=\"language-javascript\"><code>import { useParams } from 'react-router-dom';\r\n\r\n// Component that displays a specific user\r\nfunction UserProfile() {\r\n  const { userId } = useParams();  // Extract the :userId from URL\r\n  \r\n  return (\r\n    &lt;div&gt;\r\n      &lt;h1&gt;User Profile&lt;/h1&gt;\r\n      &lt;p&gt;Showing details for user: {userId}&lt;/p&gt;  {/* Shows the actual ID */}\r\n    &lt;/div&gt;\r\n  );\r\n}\r\n\r\n// Router setup\r\nconst router = createBrowserRouter([\r\n  {\r\n    path: \"/users/:userId\",       // :userId captures any value\r\n    element: &lt;UserProfile /&gt;      // /users/123 &rarr; userId = \"123\"\r\n  },                              // /users/abc &rarr; userId = \"abc\"\r\n  {\r\n    path: \"/posts/:postId/comments/:commentId\",  // Multiple parameters!\r\n    element: &lt;CommentDetail /&gt;    // Extract both postId and commentId\r\n  }\r\n]);</code></pre>\r\n</div>"},{"id":"ye961s21dylra98","title":" Protected Routes","slug":" protected routes","tier":"üü£","description":"$3e"},{"id":"9et06zij010i2nf","title":"useRoutes Config","slug":"useRoutes config","tier":"üü£","description":"$3f"},{"id":"6uugpl55w40h075","title":"Code-Splitting","slug":"code-splitting","tier":"üü£","description":"$40"},{"id":"trl64w3bkma1hsz","title":" Error Boundaries with errorElement","slug":" Error boundaries with errorElement","tier":"üü£","description":"$41"},{"id":"221m8355p40j175","title":"Scroll Restoration","slug":"scroll restoration","tier":"üü£","description":"$42"},{"id":"66hk1w36p9j7afr","title":"Route Loaders + Actions (React Router 6.4+)","slug":"Route Loaders + actions (React Router 6.4+)","tier":"üü£","description":"$43"}]},{"collectionId":"pbc_484971879","collectionName":"Categories","created":"2025-05-28 08:32:10.980Z","desription":"How to make React apps fast.","display_order":6,"id":"dq8i93s83f13y92","name":"Performance Optimization","slug":"performance optimization","updated":"2025-05-28 08:32:10.980Z","topics":[{"id":"084qv9yewb13g27","title":"Key Prop Importance","slug":"Key Prop importance","tier":"üü¢","description":"$44"},{"id":"7hedemb75wd88dw","title":"React.memo()","slug":"react.memo()","tier":"üîµ","description":"$45"},{"id":"4a799n28209o276","title":"React Profiler","slug":"react profiler","tier":"üîµ","description":"$46"},{"id":"lc8jf211s2m7mls","title":"Code Splitting (React.lazy, Suspense)","slug":"Code splitting (React.lazy, Suspense)","tier":"üü£","description":"$47"},{"id":"j140k5605r40108","title":"Virtualization (react-window)","slug":"virtualization (react-window)","tier":"üü£","description":"$48"},{"id":"i4etwgo62l722bm","title":"Streaming with Suspense","slug":"Streaming with suspense","tier":"üü£","description":"$49"},{"id":"0qb832264s6i12b","title":"Concurrent Rendering Optimization","slug":"Concurrent Rendering optimization","tier":"üü£","description":"$4a"}]},{"collectionId":"pbc_484971879","collectionName":"Categories","created":"2025-05-28 08:32:44.250Z","desription":"More scalable ways to manage app-wide state.","display_order":7,"id":"qm9bk30g16188p0","name":"Context & State Libraries","slug":"context & state libraries","updated":"2025-05-28 08:32:44.250Z","topics":[{"id":"1us752yp32ijxrx","title":"createContext & Context.Provider","slug":"createContext & context.Provider","tier":"üü¢","description":"$4b"},{"id":"60qr1h2n01yfjd5","title":"use() for Consuming Context (Server Components)","slug":"use() for Consuming Context (server Components)","tier":"üü¢","description":"$4c"},{"id":"p704o837d1929mi","title":"Updating Context","slug":"Updating context","tier":"üîµ","description":"$4d"},{"id":"cryu112a36ayh4t","title":"Avoiding Prop Drilling","slug":"Avoiding Prop drilling","tier":"üîµ","description":"$4e"},{"id":"17q8edv5c5iw711","title":"Context Performance Tricks","slug":"Context Performance tricks","tier":"üü£","description":"$4f"}]},{"collectionId":"pbc_484971879","collectionName":"Categories","created":"2025-05-28 08:34:15.580Z","desription":"Powerful advanced techniques and architecture topics.","display_order":9,"id":"dxx07spj2x36az5","name":"Specialized React Concepts","slug":"specialized react concepts","updated":"2025-05-28 08:34:15.580Z","topics":[{"id":"8c2btmrybp40j3s","title":"Error Boundaries","slug":"Error boundaries","tier":"üü¢","description":"$50"},{"id":"n41kuf0m9fuhoyr","title":"Portals","slug":"portals","tier":"üü¢","description":"$51"},{"id":"koin2nd9xaz5k09","title":"React.forwardRef","slug":"React.forwardref","tier":"üü¢","description":"$52"},{"id":"d1e29035u610q65","title":"Server Components Fundamentals","slug":"Server Components fundamentals","tier":"üü¢","description":"$53"},{"id":"191fuxiyecu329e","title":"Server Actions Basics","slug":"Server Actions basics","tier":"üü¢","description":"$54"},{"id":"r17g0v87htgu0t8","title":"Error Handling","slug":"Error handling","tier":"üîµ","description":"$55"},{"id":"75kus30m0n9k668","title":"Forms with Server Actions","slug":"Forms with Server actions","tier":"üîµ","description":"$56"},{"id":"14j19vqt01k51a5","title":"Concurrent Rendering & Boundaries ","slug":"Concurrent Rendering & boundaries ","tier":"üü£","description":"$57"}]}]}]]}]
